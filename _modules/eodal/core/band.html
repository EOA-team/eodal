
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>eodal.core.band &#8212; eodal 0.2.3 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for eodal.core.band</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A band is a two-dimensional array that can be located via a spatial coordinate system.</span>
<span class="sd">Each band thus has a name and an array of values, which are usually numeric.</span>

<span class="sd">It relies on ``rasterio`` for all in- and output operations to read data from files</span>
<span class="sd">(or URIs) using ``GDAL`` drivers.</span>

<span class="sd">eodal stores band data basically as ``numpy`` arrays. Masked arrays of the class</span>
<span class="sd">`~numpy.ma.MaskedArray` are also supported. For very large data sets that exceed the</span>
<span class="sd">RAM of the computer, ``zarr`` can be used.</span>

<span class="sd">Copyright (C) 2022 Lukas Valentin Graf</span>

<span class="sd">This program is free software: you can redistribute it and/or modify</span>
<span class="sd">it under the terms of the GNU General Public License as published by</span>
<span class="sd">the Free Software Foundation, either version 3 of the License, or</span>
<span class="sd">(at your option) any later version.</span>

<span class="sd">This program is distributed in the hope that it will be useful,</span>
<span class="sd">but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="sd">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="sd">GNU General Public License for more details.</span>

<span class="sd">You should have received a copy of the GNU General Public License</span>
<span class="sd">along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.ticker</span> <span class="k">as</span> <span class="nn">ticker</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">rasterio</span> <span class="k">as</span> <span class="nn">rio</span>
<span class="kn">import</span> <span class="nn">rasterio.mask</span>
<span class="kn">import</span> <span class="nn">uuid</span>
<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>
<span class="kn">import</span> <span class="nn">zarr</span>

<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">matplotlib.axes</span> <span class="kn">import</span> <span class="n">Axes</span>
<span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="kn">import</span> <span class="n">ListedColormap</span>
<span class="kn">from</span> <span class="nn">matplotlib.figure</span> <span class="kn">import</span> <span class="n">figaspect</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="kn">import</span> <span class="n">make_axes_locatable</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">rasterio</span> <span class="kn">import</span> <span class="n">Affine</span><span class="p">,</span> <span class="n">features</span>
<span class="kn">from</span> <span class="nn">rasterio.coords</span> <span class="kn">import</span> <span class="n">BoundingBox</span>
<span class="kn">from</span> <span class="nn">rasterio.crs</span> <span class="kn">import</span> <span class="n">CRS</span>
<span class="kn">from</span> <span class="nn">rasterio.drivers</span> <span class="kn">import</span> <span class="n">driver_from_extension</span>
<span class="kn">from</span> <span class="nn">rasterio.enums</span> <span class="kn">import</span> <span class="n">Resampling</span>
<span class="kn">from</span> <span class="nn">rasterstats</span> <span class="kn">import</span> <span class="n">zonal_stats</span>
<span class="kn">from</span> <span class="nn">rasterstats.utils</span> <span class="kn">import</span> <span class="n">check_stats</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">box</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">,</span> <span class="n">Point</span><span class="p">,</span> <span class="n">Polygon</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">from</span> <span class="nn">eodal.config</span> <span class="kn">import</span> <span class="n">get_settings</span>
<span class="kn">from</span> <span class="nn">eodal.core.operators</span> <span class="kn">import</span> <span class="n">Operator</span>
<span class="kn">from</span> <span class="nn">eodal.core.utils.geometry</span> <span class="kn">import</span> <span class="n">check_geometry_types</span><span class="p">,</span> <span class="n">convert_3D_2D</span>
<span class="kn">from</span> <span class="nn">eodal.core.utils.raster</span> <span class="kn">import</span> <span class="n">get_raster_attributes</span><span class="p">,</span> <span class="n">bounds_window</span>
<span class="kn">from</span> <span class="nn">eodal.utils.arrays</span> <span class="kn">import</span> <span class="n">count_valid</span><span class="p">,</span> <span class="n">upsample_array</span><span class="p">,</span> <span class="n">array_from_points</span>
<span class="kn">from</span> <span class="nn">eodal.utils.exceptions</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">BandNotFoundError</span><span class="p">,</span>
    <span class="n">DataExtractionError</span><span class="p">,</span>
    <span class="n">ResamplingFailedError</span><span class="p">,</span>
    <span class="n">ReprojectionError</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">eodal.utils.reprojection</span> <span class="kn">import</span> <span class="n">reproject_raster_dataset</span><span class="p">,</span> <span class="n">check_aoi_geoms</span>

<span class="n">Settings</span> <span class="o">=</span> <span class="n">get_settings</span><span class="p">()</span>


<div class="viewcode-block" id="BandOperator"><a class="viewcode-back" href="../../../packages/eodal.core.band.html#eodal.core.band.BandOperator">[docs]</a><span class="k">class</span> <span class="nc">BandOperator</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Band operator supporting basic algebraic operations on `Band` objects</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="BandOperator.calc"><a class="viewcode-back" href="../../../packages/eodal.core.band.html#eodal.core.band.BandOperator.calc">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">calc</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">a</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">operator</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">band_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">right_sided</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        executes a custom algebraic operator on Band objects</span>

<span class="sd">        :param a:</span>
<span class="sd">            `Band` object with values (non-empty)</span>
<span class="sd">        :param other:</span>
<span class="sd">            scalar, `Band` or two-dimemsional `numpy.array` to use on the right-hand</span>
<span class="sd">            side of the operator. If a `numpy.array` is passed the array must</span>
<span class="sd">            have the same x and y dimensions as the current `Band` data.</span>
<span class="sd">        :param operator:</span>
<span class="sd">            symbolic representation of the operator (e.g., &#39;+&#39;</span>
<span class="sd">            for addition)</span>
<span class="sd">        :param inplace:</span>
<span class="sd">            returns a new `Band` object if False (default) otherwise overwrites</span>
<span class="sd">            the current `Band` data</span>
<span class="sd">        :param band_name:</span>
<span class="sd">            optional name of the resulting `Band` object if inplace is False.</span>
<span class="sd">        :param right_sided:</span>
<span class="sd">            optional flag indicated that the order of `a` and `other` has to be</span>
<span class="sd">            switched. `False` by default. Set to `True` if the order of argument</span>
<span class="sd">            matters, i.e., for right-hand sided expression in case of subtraction,</span>
<span class="sd">            division and power.</span>
<span class="sd">        :returns:</span>
<span class="sd">            `numpy.ndarray` if inplace is False, None instead</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other_copy</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">other_is_band</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">check_operator</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">operator</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Passed array has wrong dimensions. Expected </span><span class="si">{</span><span class="n">a</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot; - Got </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Band</span><span class="p">):</span>
            <span class="n">other_copy</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">values</span>
            <span class="n">other_is_band</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># perform the operation</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># mind the order which is important for some operators</span>
            <span class="k">if</span> <span class="n">right_sided</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;other </span><span class="si">{</span><span class="n">operator</span><span class="si">}</span><span class="s2"> a.values&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;a.values </span><span class="si">{</span><span class="n">operator</span><span class="si">}</span><span class="s2"> other&quot;</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">cls</span><span class="o">.</span><span class="n">BandMathError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not execute </span><span class="si">{</span><span class="n">expr</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># return result or overwrite band data</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="s2">&quot;values&quot;</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">band_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">band_name</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">band_name</span>
                <span class="k">if</span> <span class="n">other_is_band</span><span class="p">:</span>
                    <span class="n">band_name</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">operator</span><span class="si">}{</span><span class="n">other_copy</span><span class="o">.</span><span class="n">band_name</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;band_name&quot;</span><span class="p">:</span> <span class="n">band_name</span><span class="p">})</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;values&quot;</span><span class="p">:</span> <span class="n">res</span><span class="p">})</span>
            <span class="k">return</span> <span class="n">Band</span><span class="p">(</span><span class="o">**</span><span class="n">attrs</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="GeoInfo"><a class="viewcode-back" href="../../../packages/eodal.core.band.html#eodal.core.band.GeoInfo">[docs]</a><span class="k">class</span> <span class="nc">GeoInfo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for storing geo-localization information required to</span>
<span class="sd">    reference a raster band object in a spatial coordinate system.</span>
<span class="sd">    At its core this class contains all the attributes necessary to</span>
<span class="sd">    define a ``Affine`` transformation.</span>

<span class="sd">    :attrib epsg:</span>
<span class="sd">        EPSG code of the spatial reference system the raster data is projected</span>
<span class="sd">        to.</span>
<span class="sd">    :attrib ulx:</span>
<span class="sd">        upper left x coordinate of the raster band in the spatial reference system</span>
<span class="sd">        defined by the EPSG code. We assume ``GDAL`` defaults, therefore the coordinate</span>
<span class="sd">        should refer to the upper left *pixel* corner.</span>
<span class="sd">    :attrib uly:</span>
<span class="sd">        upper left y coordinate of the raster band in the spatial reference system</span>
<span class="sd">        defined by the EPSG code. We assume ``GDAL`` defaults, therefore the coordinate</span>
<span class="sd">        should refer to the upper left *pixel* corner.</span>
<span class="sd">    :attrib pixres_x:</span>
<span class="sd">        pixel size (aka spatial resolution) in x direction. The unit is defined by</span>
<span class="sd">        the spatial coordinate system given by the EPSG code.</span>
<span class="sd">    :attrib pixres_y:</span>
<span class="sd">        pixel size (aka spatial resolution) in y direction. The unit is defined by</span>
<span class="sd">        the spatial coordinate system given by the EPSG code.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="GeoInfo.__init__"><a class="viewcode-back" href="../../../packages/eodal.core.band.html#eodal.core.band.GeoInfo.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">epsg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">CRS</span><span class="p">,</span>
        <span class="n">ulx</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">uly</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">pixres_x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">pixres_y</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Class constructor to get a new ``GeoInfo`` instance.</span>

<span class="sd">        &gt;&gt;&gt; geo_info = GeoInfo(4326, 11., 48., 0.02, 0.02)</span>
<span class="sd">        &gt;&gt;&gt; affine = geo_info.as_affine()</span>

<span class="sd">        :param epsg:</span>
<span class="sd">            EPSG code identifying the spatial reference system (e.g., 4326 for</span>
<span class="sd">            WGS84).</span>
<span class="sd">        :param ulx:</span>
<span class="sd">            upper left x coordinate in units of the spatial reference system.</span>
<span class="sd">            Should refer to the upper left pixel corner.</span>
<span class="sd">        :param uly:</span>
<span class="sd">            upper left x coordinate in units of the spatial reference system.</span>
<span class="sd">            Should refer to the upper left pixel corner</span>
<span class="sd">        :param pixres_x:</span>
<span class="sd">            pixel grid cell size in x direction in units of the spatial reference</span>
<span class="sd">            system.</span>
<span class="sd">        :param pixres_y:</span>
<span class="sd">            pixel grid cell size in y direction in units of the spatial reference</span>
<span class="sd">            system.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make sure the EPSG code is valid</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">epsg</span><span class="p">,</span> <span class="n">CRS</span><span class="p">):</span>
            <span class="n">epsg</span> <span class="o">=</span> <span class="n">epsg</span><span class="o">.</span><span class="n">to_epsg</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">CRS</span><span class="o">.</span><span class="n">from_epsg</span><span class="p">(</span><span class="n">epsg</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;epsg&quot;</span><span class="p">,</span> <span class="n">epsg</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;ulx&quot;</span><span class="p">,</span> <span class="n">ulx</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;uly&quot;</span><span class="p">,</span> <span class="n">uly</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;pixres_x&quot;</span><span class="p">,</span> <span class="n">pixres_x</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;pixres_y&quot;</span><span class="p">,</span> <span class="n">pixres_y</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;GeoInfo object attributes are immutable&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__delattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;GeoInfo object attributes are immutable&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>

<div class="viewcode-block" id="GeoInfo.as_affine"><a class="viewcode-back" href="../../../packages/eodal.core.band.html#eodal.core.band.GeoInfo.as_affine">[docs]</a>    <span class="k">def</span> <span class="nf">as_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Affine</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an ``rasterio.Affine`` compatible affine transformation</span>

<span class="sd">        :returns:</span>
<span class="sd">            ``GeoInfo`` instance as ``rasterio.Affine``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Affine</span><span class="p">(</span>
            <span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pixres_x</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ulx</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">e</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pixres_y</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">uly</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="GeoInfo.from_affine"><a class="viewcode-back" href="../../../packages/eodal.core.band.html#eodal.core.band.GeoInfo.from_affine">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_affine</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">affine</span><span class="p">:</span> <span class="n">Affine</span><span class="p">,</span> <span class="n">epsg</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a ``GeoInfo`` instance from a ``rasterio.Affine`` object</span>

<span class="sd">        :param affine:</span>
<span class="sd">            ``rasterio.Affine`` object</span>
<span class="sd">        :param epsg:</span>
<span class="sd">            EPSG code identifying the spatial coordinate system</span>
<span class="sd">        :returns:</span>
<span class="sd">            new ``GeoInfo`` instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">epsg</span><span class="o">=</span><span class="n">epsg</span><span class="p">,</span> <span class="n">ulx</span><span class="o">=</span><span class="n">affine</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">uly</span><span class="o">=</span><span class="n">affine</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="n">pixres_x</span><span class="o">=</span><span class="n">affine</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">pixres_y</span><span class="o">=</span><span class="n">affine</span><span class="o">.</span><span class="n">e</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="WavelengthInfo"><a class="viewcode-back" href="../../../packages/eodal.core.band.html#eodal.core.band.WavelengthInfo">[docs]</a><span class="k">class</span> <span class="nc">WavelengthInfo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for storing information about the spectral wavelength of a</span>
<span class="sd">    raster band. Many optical sensors record data in spectral channels</span>
<span class="sd">    with a central wavelength and spectral band width.</span>

<span class="sd">    :attrib central_wavelength:</span>
<span class="sd">        central spectral wavelength.</span>
<span class="sd">    :attrib band_width:</span>
<span class="sd">        spectral band width. This is defined as the difference between</span>
<span class="sd">        the upper and lower spectral wavelength a sensor is recording</span>
<span class="sd">        in a spectral channel.</span>
<span class="sd">    :attrib wavelength_unit:</span>
<span class="sd">        physical unit in which `central_wavelength` and `band_width`</span>
<span class="sd">        are recorded. Usually &#39;nm&#39; (nano-meters) or &#39;um&#39; (micro-meters)</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="WavelengthInfo.__init__"><a class="viewcode-back" href="../../../packages/eodal.core.band.html#eodal.core.band.WavelengthInfo.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">central_wavelength</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">wavelength_unit</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">band_width</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor to derive a new `WavelengthInfo` instance for</span>
<span class="sd">        a (spectral) raster band.</span>

<span class="sd">        :param central_wavelength:</span>
<span class="sd">            central wavelength of the band</span>
<span class="sd">        :param wavelength_unit:</span>
<span class="sd">            physical unit in which the wavelength is provided</span>
<span class="sd">        :param band_width:</span>
<span class="sd">            width of the spectral band (optional). If not provided</span>
<span class="sd">            assumes a width of zero wavelength units.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># wavelengths must be &gt; 0:</span>
        <span class="k">if</span> <span class="n">central_wavelength</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wavelengths must be positive!&quot;</span><span class="p">)</span>
        <span class="c1"># band widths must be positive numbers</span>
        <span class="k">if</span> <span class="n">band_width</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Bandwidth must not be negative&quot;</span><span class="p">)</span>

        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;central_wavelength&quot;</span><span class="p">,</span> <span class="n">central_wavelength</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;wavelength_unit&quot;</span><span class="p">,</span> <span class="n">wavelength_unit</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;band_width&quot;</span><span class="p">,</span> <span class="n">band_width</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;WavelengthInfo object attributes are immutable&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__delattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;WavelengthInfo object attributes are immutable&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Band"><a class="viewcode-back" href="../../../packages/eodal.core.band.html#eodal.core.band.Band">[docs]</a><span class="k">class</span> <span class="nc">Band</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for storing, accessing and modifying a raster band</span>

<span class="sd">    :attrib band_name:</span>
<span class="sd">        the band name identifies the raster band (e.g., &#39;B1&#39;). It can be</span>
<span class="sd">        any character string</span>
<span class="sd">    :attrib values:</span>
<span class="sd">        the actual raster data as ``numpy.ndarray``, ``numpy.ma.MaskedArray`` or</span>
<span class="sd">        ``zarr``. The type depends on how the constructor is called.</span>
<span class="sd">    :attrib geo_info:</span>
<span class="sd">        `GeoInfo` object defining the spatial reference system, upper left</span>
<span class="sd">        corner and pixel size (spatial resolution)</span>
<span class="sd">    :attrib band_alias:</span>
<span class="sd">        optional band alias to use in addition to `band_name`. Both, `band_name`</span>
<span class="sd">        and `band_alias` are interchangeable.</span>
<span class="sd">    :attrib wavelength_info:</span>
<span class="sd">        optional wavelength info about the band to allow for localizing the</span>
<span class="sd">        band data in the spectral domain (mostly required for data from optical</span>
<span class="sd">        imaging sensors).</span>
<span class="sd">    :attrib scale:</span>
<span class="sd">        scale (aka gain) parameter of the raster data.</span>
<span class="sd">    :attrib offset:</span>
<span class="sd">        offset parameter of the raster data.</span>
<span class="sd">    :attrib unit:</span>
<span class="sd">        optional (SI) physical unit of the band data (e.g., &#39;meters&#39; for</span>
<span class="sd">        elevation data)</span>
<span class="sd">    :attrib nodata:</span>
<span class="sd">        numeric value indicating no-data. If not provided the nodata value</span>
<span class="sd">        is set to ``numpy.nan`` for floating point data, 0 and -999 for</span>
<span class="sd">        unsigned and signed integer data, respectively.</span>
<span class="sd">    :attrib is_tiled:</span>
<span class="sd">        boolean flag indicating if the raster data is sub-divided into</span>
<span class="sd">        tiles. False (zero) by default.</span>
<span class="sd">    :attrib area_or_point:</span>
<span class="sd">        Following ``GDAL`` standards, might be either `Area` (GDAL default) or</span>
<span class="sd">        `Point`. When `Area` pixel coordinates refer to the upper left corner of the</span>
<span class="sd">        pixel, whereas `Point` indicates that pixel coordinates are from the center</span>
<span class="sd">        of the pixel.</span>
<span class="sd">    :attrib alias:</span>
<span class="sd">        True if the band has a `band_alias`</span>
<span class="sd">    :attrib bounds:</span>
<span class="sd">        image bounds in cartographic projection</span>
<span class="sd">    :attrib coordinates:</span>
<span class="sd">        image coordinates in x and y direction</span>
<span class="sd">    :attrib crs:</span>
<span class="sd">        coordinate reference system as EPSG code</span>
<span class="sd">    :attrib has_alias:</span>
<span class="sd">        True if the band has a `band_alias`</span>
<span class="sd">    :attrib is_zarr:</span>
<span class="sd">        True if the band data is stored as `zarr`</span>
<span class="sd">    :attrib is_ndarray:</span>
<span class="sd">        True if the band data is stored as `numpy.ndarray`</span>
<span class="sd">    :attrib is_masked_array:</span>
<span class="sd">        True if the band data is stored as `numpy.ma.core.maskedArray`</span>
<span class="sd">    :attrib meta:</span>
<span class="sd">        `rasterio` compatible representation of essential image metadata</span>
<span class="sd">    :attrib transform:</span>
<span class="sd">        `Affine` transform representation of the image geo-localisation</span>
<span class="sd">    :attrib vector_features:</span>
<span class="sd">        `geopandas.GeoDataFrame` with vector features used for reading the image</span>
<span class="sd">        (clipping or masking). Can be None if no features were used for reading.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Band.__init__"><a class="viewcode-back" href="../../../packages/eodal.core.band.html#eodal.core.band.Band.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">band_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">values</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">,</span> <span class="n">zarr</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Array</span><span class="p">],</span>
        <span class="n">geo_info</span><span class="p">:</span> <span class="n">GeoInfo</span><span class="p">,</span>
        <span class="n">band_alias</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">wavelength_info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">WavelengthInfo</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scale</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">offset</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">unit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">nodata</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">is_tiled</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">area_or_point</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Area&quot;</span><span class="p">,</span>
        <span class="n">vector_features</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor to instantiate a new band object.</span>

<span class="sd">        :param band_name:</span>
<span class="sd">            name of the band.</span>
<span class="sd">        :param values:</span>
<span class="sd">            data of the band. Can be any numpy ``ndarray`` or ``maskedArray``</span>
<span class="sd">            as well as a ``zarr`` instance as long as its two-dimensional.</span>
<span class="sd">        :param geo_info:</span>
<span class="sd">            `~eodal.core.band.GeoInfo` instance to allow for localizing</span>
<span class="sd">            the band data in a spatial reference system</span>
<span class="sd">        :param band_alias:</span>
<span class="sd">            optional alias name of the band</span>
<span class="sd">        :param wavelength_info:</span>
<span class="sd">            optional `~eodal.core.band.WavelengthInfo` instance denoting</span>
<span class="sd">            the spectral wavelength properties of the band. It is recommended</span>
<span class="sd">            to pass this parameter for optical sensor data.</span>
<span class="sd">        :param scale:</span>
<span class="sd">            optional scale (aka gain) factor for the raster band data. Many</span>
<span class="sd">            floating point datasets are scaled by a large number to allow for</span>
<span class="sd">            storing data as integer arrays to save disk space. The scale factor</span>
<span class="sd">            should allow to scale the data back into its original value range.</span>
<span class="sd">            For instance, Sentinel-2 MSI data is stored as unsigned 16-bit</span>
<span class="sd">            integer arrays but actually contain reflectance factor values between</span>
<span class="sd">            0 and 1. If not provided, `scale` is set to 1.</span>
<span class="sd">        :param offset:</span>
<span class="sd">            optional offset for the raster band data. As for the gain factor the</span>
<span class="sd">            idea is to scale the original band data in such a way that it&#39;s either</span>
<span class="sd">            possible to store the data in a certain data type or to avoid certain</span>
<span class="sd">            values. If not provided, `offset` is set to 0.</span>
<span class="sd">        :param unit:</span>
<span class="sd">            optional (SI) physical unit of the band data (e.g., &#39;meters&#39; for</span>
<span class="sd">            elevation data)</span>
<span class="sd">        :param nodata:</span>
<span class="sd">            numeric value indicating no-data. If not provided the nodata value</span>
<span class="sd">            is set to ``numpy.nan`` for floating point data, 0 and -999 for</span>
<span class="sd">            unsigned and signed integer data, respectively.</span>
<span class="sd">        :param is_tiled:</span>
<span class="sd">            boolean flag indicating if the raster data is sub-divided into</span>
<span class="sd">            tiles. False (zero) by default.</span>
<span class="sd">        :param area_or_point:</span>
<span class="sd">            Following ``GDAL`` standards, might be either `Area` (GDAL default) or</span>
<span class="sd">            `Point`. When `Area` pixel coordinates refer to the upper left corner of the</span>
<span class="sd">            pixel, whereas `Point` indicates that pixel coordinates are from the center</span>
<span class="sd">            of the pixel.</span>
<span class="sd">        :param vector_features:</span>
<span class="sd">            `geopandas.GeoDataFrame` with vector features used for reading the image</span>
<span class="sd">            (clipping or masking). Can be None if no features were used for reading</span>
<span class="sd">            (optional).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># make sure the passed values are 2-dimensional</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only two-dimensional arrays are allowed&quot;</span><span class="p">)</span>

        <span class="c1"># check nodata value</span>
        <span class="k">if</span> <span class="n">nodata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;float16&quot;</span><span class="p">,</span> <span class="s2">&quot;float32&quot;</span><span class="p">,</span> <span class="s2">&quot;float64&quot;</span><span class="p">]:</span>
                <span class="n">nodata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">elif</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;int16&quot;</span><span class="p">,</span> <span class="s2">&quot;int32&quot;</span><span class="p">,</span> <span class="s2">&quot;int64&quot;</span><span class="p">]:</span>
                <span class="n">nodata</span> <span class="o">=</span> <span class="o">-</span><span class="mi">999</span>
            <span class="k">elif</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;uint8&quot;</span><span class="p">,</span> <span class="s2">&quot;uint16&quot;</span><span class="p">,</span> <span class="s2">&quot;uint32&quot;</span><span class="p">,</span> <span class="s2">&quot;uint64&quot;</span><span class="p">]:</span>
                <span class="n">nodata</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># make sure vector features is a valid GeoDataFrame</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_vector_features</span><span class="p">(</span><span class="n">vector_features</span><span class="p">)</span>

        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;band_name&quot;</span><span class="p">,</span> <span class="n">band_name</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;values&quot;</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;geo_info&quot;</span><span class="p">,</span> <span class="n">geo_info</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;band_alias&quot;</span><span class="p">,</span> <span class="n">band_alias</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;wavelength_info&quot;</span><span class="p">,</span> <span class="n">wavelength_info</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;scale&quot;</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;offset&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;unit&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;nodata&quot;</span><span class="p">,</span> <span class="n">nodata</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;is_tiled&quot;</span><span class="p">,</span> <span class="n">is_tiled</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;area_or_point&quot;</span><span class="p">,</span> <span class="n">area_or_point</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;vector_features&quot;</span><span class="p">,</span> <span class="n">vector_features</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Band object attributes are immutable&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__delattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Band object attributes immutable&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BandOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;+&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BandOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;+&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BandOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BandOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="n">right_sided</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BandOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;**&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rpow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BandOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;**&quot;</span><span class="p">,</span> <span class="n">right_sided</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BandOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;&lt;=&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rle__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BandOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;&lt;=&quot;</span><span class="p">,</span> <span class="n">right_sided</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BandOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;&gt;=&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BandOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;&gt;=&quot;</span><span class="p">,</span> <span class="n">right_sided</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BandOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BandOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="n">right_sided</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BandOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BandOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BandOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;!=&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BandOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;!=&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BandOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;==&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__req__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BandOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;==&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BandOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;&gt;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rgt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BandOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;&gt;&quot;</span><span class="p">,</span> <span class="n">right_sided</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BandOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;&lt;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rlt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BandOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="n">right_sided</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;EOdal Band</span><span class="se">\n</span><span class="s2">---------.</span><span class="se">\n</span><span class="s2">Name:    </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">band_name</span><span class="si">}</span><span class="se">\n</span><span class="s2">GeoInfo:    &quot;</span> <span class="o">+</span> \
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_info</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">alias</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Alias of the band name (if available)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_alias</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_alias</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">box</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Spatial bounding box of the band&quot;&quot;&quot;</span>
        <span class="n">minx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_info</span><span class="o">.</span><span class="n">ulx</span>
        <span class="n">maxx</span> <span class="o">=</span> <span class="n">minx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncols</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_info</span><span class="o">.</span><span class="n">pixres_x</span>
        <span class="n">maxy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_info</span><span class="o">.</span><span class="n">uly</span>
        <span class="n">miny</span> <span class="o">=</span> <span class="n">maxy</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_info</span><span class="o">.</span><span class="n">pixres_y</span>
        <span class="k">return</span> <span class="n">box</span><span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;x-y spatial band coordinates&quot;&quot;&quot;</span>
        <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">transform</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nx</span><span class="p">))</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">transform</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ny</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ny</span><span class="p">))</span>

        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="n">y</span><span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">crs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CRS</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Coordinate Reference System of the band&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CRS</span><span class="o">.</span><span class="n">from_epsg</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_info</span><span class="o">.</span><span class="n">epsg</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_alias</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks if a color name can be used for aliasing&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_alias</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_zarr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks if the band values are a zarr array&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">zarr</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Array</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_ndarray</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks if the band values are a numpy ndarray&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_masked_array</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_masked_array</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks if the band values are a numpy masked array&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">meta</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provides a ``rasterio`` compatible dictionary with raster</span>
<span class="sd">        metadata</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;width&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="p">,</span>
            <span class="s2">&quot;height&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">,</span>
            <span class="s2">&quot;transform&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_info</span><span class="o">.</span><span class="n">as_affine</span><span class="p">(),</span>
            <span class="s2">&quot;count&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
            <span class="s2">&quot;crs&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nrows</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of rows of the band&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ncols</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of columns of the band&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Affine</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Affine transformation of the band&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_info</span><span class="o">.</span><span class="n">as_affine</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_check_vector_features</span><span class="p">(</span><span class="n">vector_features</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Asserts that passed GeoDataFrame has a CRS</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">vector_features</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vector_features</span><span class="p">,</span> <span class="n">Path</span><span class="p">):</span>
                <span class="n">vector_features</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">vector_features</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">vector_features</span><span class="o">.</span><span class="n">crs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot handle vector features without spatial coordinate&quot;</span>
                    <span class="s2">&quot;reference system&quot;</span>
                <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_pixel_geometries</span><span class="p">(</span>
        <span class="n">vector_features</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Path</span><span class="p">,</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">],</span>
        <span class="n">fpath_raster</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Path</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">raster_crs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">CRS</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process passed pixel geometries including reprojection of the</span>
<span class="sd">        vector features (if required) into the spatial reference system</span>
<span class="sd">        of the raster band and extraction of centroid coordinates if</span>
<span class="sd">        the vector features are of type ``Polygon`` or ``MultiPolygon``</span>

<span class="sd">        :param vector_features:</span>
<span class="sd">            passed vector features to calling instance or class method</span>
<span class="sd">        :param fpath_raster:</span>
<span class="sd">            optional file path to the raster dataset. To be used when</span>
<span class="sd">            called from a classmethod</span>
<span class="sd">        :param raster_crs:</span>
<span class="sd">            optional raster EPSG code. To be used when called from an</span>
<span class="sd">            instance method.</span>
<span class="sd">        :returns:</span>
<span class="sd">            ``GeoDataFrame`` with ``Point`` features for extracting</span>
<span class="sd">            pixel values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check input point features</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="n">check_aoi_geoms</span><span class="p">(</span>
            <span class="n">in_dataset</span><span class="o">=</span><span class="n">vector_features</span><span class="p">,</span>
            <span class="n">fname_raster</span><span class="o">=</span><span class="n">fpath_raster</span><span class="p">,</span>
            <span class="n">raster_crs</span><span class="o">=</span><span class="n">raster_crs</span><span class="p">,</span>
            <span class="n">full_bounding_box_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">allowed_geometry_types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Point&quot;</span><span class="p">,</span> <span class="s2">&quot;Polygon&quot;</span><span class="p">,</span> <span class="s2">&quot;MultiPolygon&quot;</span><span class="p">]</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="n">check_geometry_types</span><span class="p">(</span>
            <span class="n">in_dataset</span><span class="o">=</span><span class="n">gdf</span><span class="p">,</span> <span class="n">allowed_geometry_types</span><span class="o">=</span><span class="n">allowed_geometry_types</span>
        <span class="p">)</span>

        <span class="c1"># convert to centroids if the geometries are not of type Point</span>
        <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">centroid</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">geom_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Polygon&quot;</span><span class="p">,</span> <span class="s2">&quot;MultiPolygon&quot;</span><span class="p">]</span> <span class="k">else</span> <span class="n">x</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">gdf</span>

<div class="viewcode-block" id="Band.from_rasterio"><a class="viewcode-back" href="../../../packages/eodal.core.band.html#eodal.core.band.Band.from_rasterio">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_rasterio</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">fpath_raster</span><span class="p">:</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">Dict</span><span class="p">,</span>
        <span class="n">band_idx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">band_name_src</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">band_name_dst</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;B1&quot;</span><span class="p">,</span>
        <span class="n">vector_features</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Path</span><span class="p">,</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">full_bounding_box_only</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">epsg_code</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new ``Band`` instance from any raster dataset understood</span>
<span class="sd">        by ``rasterio``. Reads exactly **one** band from the input dataset!</span>

<span class="sd">        NOTE:</span>
<span class="sd">            To read a spatial subset of raster band data only pass</span>
<span class="sd">            `vector_features` which can be one to N (multi)polygon features.</span>
<span class="sd">            For Point features refer to the `read_pixels` method.</span>

<span class="sd">        :param fpath_raster:</span>
<span class="sd">            file-path to the raster file from which to read a band or</span>

<span class="sd">            .. versionadd:: 0.2.0</span>
<span class="sd">                can be also an `assets` dictionary returned from a STAC query</span>

<span class="sd">        :param band_idx:</span>
<span class="sd">            band index of the raster band to read (starting with 1). If not</span>
<span class="sd">            provided the first band will be always read. Ignored if</span>
<span class="sd">            `band_name_src` is provided.</span>
<span class="sd">        :param band_name_src:</span>
<span class="sd">            instead of providing a band index to read (`band_idx`) a band name</span>
<span class="sd">            can be passed. If provided `band_idx` is ignored.</span>
<span class="sd">        :param band_name_dst:</span>
<span class="sd">            name of the raster band in the resulting ``Band`` instance. If</span>
<span class="sd">            not provided the default value (&#39;B1&#39;) is used. Whenever the band</span>
<span class="sd">            name is known it is recommended to use a meaningful band name!</span>
<span class="sd">        :param vector_features:</span>
<span class="sd">            ``GeoDataFrame`` or file with vector features in a format understood</span>
<span class="sd">            by ``fiona`` with one or more vector features of type ``Polygon``</span>
<span class="sd">            or ``MultiPolygon``. Unless `full_bounding_box_only` is set to True</span>
<span class="sd">            masks out all pixels not covered by the provided vector features.</span>
<span class="sd">            Otherwise the spatial bounding box encompassing all vector features</span>
<span class="sd">            is read as a spatial subset of the input raster band.</span>
<span class="sd">            If the coordinate system of the vector differs from the raster data</span>
<span class="sd">            source the vector features are projected into the CRS of the raster</span>
<span class="sd">            band before extraction.</span>
<span class="sd">        :param full_bounding_box_only:</span>
<span class="sd">            if False (default) pixels not covered by the vector features are masked</span>
<span class="sd">            out using ``maskedArray`` in the back. If True, does not mask pixels</span>
<span class="sd">            within the spatial bounding box of the `vector_features`.</span>
<span class="sd">        :param epsg_code:</span>
<span class="sd">            custom EPSG code of the raster dataset in case the raster has no</span>
<span class="sd">            internally-described EPSG code or no EPSG code at all.</span>
<span class="sd">        :param kwargs:</span>
<span class="sd">            further key-word arguments to pass to `~eodal.core.band.Band`.</span>
<span class="sd">        :returns:</span>
<span class="sd">            new ``Band`` instance from a ``rasterio`` dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_fpath_raster</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">fpath_raster</span><span class="p">)</span>
        <span class="c1"># check if fpath_raster is STAC item or file system path</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fpath_raster</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">band_name_src</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_fpath_raster</span> <span class="o">=</span> <span class="n">_fpath_raster</span><span class="p">[</span><span class="n">band_name_src</span><span class="p">][</span><span class="s2">&quot;href&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_fpath_raster</span> <span class="o">=</span> <span class="n">_fpath_raster</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">_fpath_raster</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="n">band_idx</span><span class="p">]][</span>
                    <span class="s2">&quot;href&quot;</span>
                <span class="p">]</span>

        <span class="c1"># check vector features if provided</span>
        <span class="n">masking</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">vector_features</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">masking</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">gdf_aoi</span> <span class="o">=</span> <span class="n">check_aoi_geoms</span><span class="p">(</span>
                <span class="n">in_dataset</span><span class="o">=</span><span class="n">vector_features</span><span class="p">,</span>
                <span class="n">fname_raster</span><span class="o">=</span><span class="n">_fpath_raster</span><span class="p">,</span>
                <span class="n">full_bounding_box_only</span><span class="o">=</span><span class="n">full_bounding_box_only</span><span class="p">,</span>
                <span class="n">raster_crs</span><span class="o">=</span><span class="n">epsg_code</span>
            <span class="p">)</span>
            <span class="c1"># check for third dimension (has_z) and flatten it to 2d</span>
            <span class="n">gdf_aoi</span><span class="o">.</span><span class="n">geometry</span> <span class="o">=</span> <span class="n">convert_3D_2D</span><span class="p">(</span><span class="n">gdf_aoi</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span>

            <span class="c1"># check geometry types of the input features</span>
            <span class="n">allowed_geometry_types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Polygon&quot;</span><span class="p">,</span> <span class="s2">&quot;MultiPolygon&quot;</span><span class="p">]</span>
            <span class="n">gdf_aoi</span> <span class="o">=</span> <span class="n">check_geometry_types</span><span class="p">(</span>
                <span class="n">in_dataset</span><span class="o">=</span><span class="n">gdf_aoi</span><span class="p">,</span> <span class="n">allowed_geometry_types</span><span class="o">=</span><span class="n">allowed_geometry_types</span>
            <span class="p">)</span>

        <span class="c1"># read data using rasterio</span>
        <span class="k">with</span> <span class="n">rio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">_fpath_raster</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
            <span class="c1"># parse image attributes</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="n">get_raster_attributes</span><span class="p">(</span><span class="n">riods</span><span class="o">=</span><span class="n">src</span><span class="p">)</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;transform&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">epsg_code</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">epsg</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;crs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_epsg</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">epsg</span> <span class="o">=</span> <span class="n">epsg_code</span>
            <span class="c1"># check for area or point pixel coordinate definition</span>
            <span class="k">if</span> <span class="s2">&quot;area_or_point&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">area_or_point</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">tags</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;AREA_OR_POINT&quot;</span><span class="p">,</span> <span class="s2">&quot;Area&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">area_or_point</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;area_or_point&quot;</span><span class="p">]</span>
                <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;area_or_point&quot;</span><span class="p">)</span>
            <span class="c1"># check no data value</span>
            <span class="k">if</span> <span class="s2">&quot;nodata&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">src</span><span class="o">.</span><span class="n">nodata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">nodata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">src</span><span class="o">.</span><span class="n">nodata</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                        <span class="n">src</span><span class="o">.</span><span class="n">dtypes</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s1">&#39;Nodata must not be None. Please pass &#39;</span> <span class="o">+</span>
                        <span class="s1">&#39;`nodata` argument&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nodata</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;nodata&quot;</span><span class="p">]</span>
                <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;nodata&quot;</span><span class="p">)</span>

            <span class="c1"># overwrite band_idx if band_name_src is provided</span>
            <span class="n">band_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">descriptions</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">band_name_src</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">band_name_src</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">band_names</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">BandNotFoundError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;Could not find band &quot;</span><span class="si">{</span><span class="n">band_name_src</span><span class="si">}</span><span class="s1">&quot; &#39;</span> <span class="sa">f</span><span class="s2">&quot;in </span><span class="si">{</span><span class="n">fpath_raster</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="n">band_idx</span> <span class="o">=</span> <span class="n">band_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">band_name_src</span><span class="p">)</span>

            <span class="c1"># check if band_idx is valid</span>
            <span class="k">if</span> <span class="n">band_idx</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">band_names</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Band index </span><span class="si">{</span><span class="n">band_idx</span><span class="si">}</span><span class="s2"> is out of range for a &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;dataset with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">band_names</span><span class="p">)</span><span class="si">}</span><span class="s2"> bands&quot;</span>
                <span class="p">)</span>

            <span class="c1"># read selected band</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">masking</span><span class="p">:</span>
                <span class="c1"># TODO: add zarr support here -&gt; when is_tile == 1</span>
                <span class="k">if</span> <span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;is_tile&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="n">band_data</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">band_idx</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">band_data</span><span class="p">,</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">rio</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span>
                    <span class="n">src</span><span class="p">,</span>
                    <span class="n">gdf_aoi</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span>
                    <span class="n">crop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">all_touched</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="c1"># IMPORTANT!</span>
                    <span class="n">indexes</span><span class="o">=</span><span class="n">band_idx</span><span class="p">,</span>
                    <span class="n">filled</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="c1"># check if the mask contains any True value</span>
                <span class="c1"># if not cast the array from maskedArray to ndarray</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">band_data</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">band_data</span> <span class="o">=</span> <span class="n">band_data</span><span class="o">.</span><span class="n">data</span>

        <span class="c1"># get scale, offset and unit (if available) from kwargs or the raster</span>
        <span class="c1"># attributes. If scale, etc. are provided in kwargs, the raster attributes</span>
        <span class="c1"># are ignored. If neither kwargs nor raster attributes provide information</span>
        <span class="c1"># about scale etc., use the defaults</span>
        <span class="k">if</span> <span class="s2">&quot;scale&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;scale&quot;</span><span class="p">]</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;scale&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scale</span><span class="p">,</span> <span class="n">scales</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;scales&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">scales</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">scales</span><span class="p">[</span><span class="n">band_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="s2">&quot;offset&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;offset&quot;</span><span class="p">]</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;offset&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">offset</span><span class="p">,</span> <span class="n">offsets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;offsets&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">offsets</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">offsets</span><span class="p">[</span><span class="n">band_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="s2">&quot;unit&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;unit&quot;</span><span class="p">]</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;unit&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unit</span><span class="p">,</span> <span class="n">units</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;unit&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">units</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="n">units</span><span class="p">[</span><span class="n">band_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># make sure the nodata type matches the datatype of the</span>
        <span class="c1"># band values</span>
        <span class="k">if</span> <span class="n">band_data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s1">&#39;fc&#39;</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">nodata</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The datatype of the band data is </span><span class="si">{</span><span class="n">band_data</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2"> &quot;</span> <span class="o">+</span>
                <span class="sa">f</span><span class="s2">&quot;while the nodata value (</span><span class="si">{</span><span class="n">nodata</span><span class="si">}</span><span class="s2">) is float.</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span>
                <span class="s2">&quot;Please provide an appropriate nodata value&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">masking</span><span class="p">:</span>
            <span class="c1"># make sure to set the EPSG code</span>
            <span class="n">gdf_aoi</span><span class="o">.</span><span class="n">set_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="n">epsg</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;vector_features&quot;</span><span class="p">:</span> <span class="n">gdf_aoi</span><span class="p">})</span>

        <span class="c1"># is_tiled can only be retrived from the raster attribs</span>
        <span class="n">is_tiled</span> <span class="o">=</span> <span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;is_tiled&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># reconstruct geo-info</span>
        <span class="n">geo_info</span> <span class="o">=</span> <span class="n">GeoInfo</span><span class="p">(</span>
            <span class="n">epsg</span><span class="o">=</span><span class="n">epsg</span><span class="p">,</span>
            <span class="n">ulx</span><span class="o">=</span><span class="n">transform</span><span class="o">.</span><span class="n">c</span><span class="p">,</span>
            <span class="n">uly</span><span class="o">=</span><span class="n">transform</span><span class="o">.</span><span class="n">f</span><span class="p">,</span>
            <span class="n">pixres_x</span><span class="o">=</span><span class="n">transform</span><span class="o">.</span><span class="n">a</span><span class="p">,</span>
            <span class="n">pixres_y</span><span class="o">=</span><span class="n">transform</span><span class="o">.</span><span class="n">e</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># create new Band instance</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">band_name</span><span class="o">=</span><span class="n">band_name_dst</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="n">band_data</span><span class="p">,</span>
            <span class="n">geo_info</span><span class="o">=</span><span class="n">geo_info</span><span class="p">,</span>
            <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span>
            <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
            <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span>
            <span class="n">nodata</span><span class="o">=</span><span class="n">nodata</span><span class="p">,</span>
            <span class="n">is_tiled</span><span class="o">=</span><span class="n">is_tiled</span><span class="p">,</span>
            <span class="n">area_or_point</span><span class="o">=</span><span class="n">area_or_point</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Band.from_vector"><a class="viewcode-back" href="../../../packages/eodal.core.band.html#eodal.core.band.Band.from_vector">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_vector</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">vector_features</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Path</span><span class="p">,</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">],</span>
        <span class="n">geo_info</span><span class="p">:</span> <span class="n">GeoInfo</span><span class="p">,</span>
        <span class="n">band_name_src</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">band_name_dst</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;B1&quot;</span><span class="p">,</span>
        <span class="n">nodata_dst</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">snap_bounds</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Polygon</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dtype_src</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;float32&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new ``Band`` instance from a ``GeoDataFrame`` or a file with</span>
<span class="sd">        vector features in a format understood by ``fiona`` with geometries</span>
<span class="sd">        of type ``Point``, ``Polygon`` or ``MultiPolygon`` using a single user-</span>
<span class="sd">        defined attribute (column in the data frame). The spatial reference</span>
<span class="sd">        system of the resulting band will be the same as for the input vector data.</span>

<span class="sd">        :param vector_featueres:</span>
<span class="sd">            file-path to a vector file or ``GeoDataFrame`` from which to convert</span>
<span class="sd">            a column to raster. Please note that the column must have a numerical</span>
<span class="sd">            data type.</span>
<span class="sd">        :param GeoInfo:</span>
<span class="sd">            `~eodal.core.band.GeoInfo` instance to allow for localizing</span>
<span class="sd">            the band data in a spatial reference system</span>
<span class="sd">        :param band_name_src:</span>
<span class="sd">            name of the attribute in the vector features&#39; attribute table to</span>
<span class="sd">            convert to a new ``Band`` instance. If left empty generates a binary</span>
<span class="sd">            raster with 1 for cells overlapping the vector geometries and zero</span>
<span class="sd">            elsewhere.</span>
<span class="sd">        :param band_name_dst:</span>
<span class="sd">            name of the resulting ``Band`` instance. &quot;B1&quot; by default.</span>
<span class="sd">        :param nodata_dst:</span>
<span class="sd">            nodata value in the resulting band data to fill raster grid cells</span>
<span class="sd">            having no value assigned from the input vector features. If not</span>
<span class="sd">            provided the nodata value is set to 0 (rasterio default)</span>
<span class="sd">        :param dtype_src:</span>
<span class="sd">            data type of the resulting raster array. Per default &quot;float32&quot; is used.</span>
<span class="sd">        :param kwargs:</span>
<span class="sd">            additional key-word arguments to pass to `~eodal.core.Band`</span>
<span class="sd">        :returns:</span>
<span class="sd">            new ``Band`` instance from a vector features source</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check passed vector geometries</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vector_features</span><span class="p">,</span> <span class="n">Path</span><span class="p">):</span>
            <span class="n">gdf_aoi</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">vector_features</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gdf_aoi</span> <span class="o">=</span> <span class="n">vector_features</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">allowed_geometry_types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Point&quot;</span><span class="p">,</span> <span class="s2">&quot;Polygon&quot;</span><span class="p">,</span> <span class="s2">&quot;MultiPolygon&quot;</span><span class="p">]</span>
        <span class="n">in_gdf</span> <span class="o">=</span> <span class="n">check_geometry_types</span><span class="p">(</span>
            <span class="n">in_dataset</span><span class="o">=</span><span class="n">gdf_aoi</span><span class="p">,</span> <span class="n">allowed_geometry_types</span><span class="o">=</span><span class="n">allowed_geometry_types</span>
        <span class="p">)</span>

        <span class="c1"># check if the vector features are in the CRS specified by the geo_info passed</span>
        <span class="k">if</span> <span class="n">in_gdf</span><span class="o">.</span><span class="n">crs</span> <span class="o">!=</span> <span class="n">geo_info</span><span class="o">.</span><span class="n">epsg</span><span class="p">:</span>
            <span class="n">in_gdf</span> <span class="o">=</span> <span class="n">in_gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">geo_info</span><span class="o">.</span><span class="n">epsg</span><span class="p">)</span>

        <span class="c1"># check passed attribute selection. If the band_name_src attribute does</span>
        <span class="c1"># not exist fill it with 1 so that a binary raster can be created</span>
        <span class="k">if</span> <span class="n">band_name_src</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">band_name_src</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span>
            <span class="n">in_gdf</span><span class="p">[</span><span class="n">band_name_src</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># otherwise check if the passed attribute exists</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">band_name_src</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">in_gdf</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">band_name_src</span><span class="si">}</span><span class="s2"> not found&quot;</span><span class="p">)</span>

        <span class="c1"># infer the datatype (i.e., try if it is possible to cast the</span>
        <span class="c1"># attribute to float32, otherwise do not process the feature)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">in_gdf</span><span class="p">[</span><span class="n">band_name_src</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype_src</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Attribute &quot;</span><span class="si">{</span><span class="n">band_name_src</span><span class="si">}</span><span class="s1">&quot; seems not to be numeric&#39;</span><span class="p">)</span>

        <span class="c1"># clip features to the spatial extent of a bounding box if available</span>
        <span class="c1"># clip the input to the bounds of the snap band</span>
        <span class="k">if</span> <span class="n">snap_bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">in_gdf</span> <span class="o">=</span> <span class="n">in_gdf</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">mask</span><span class="o">=</span><span class="n">snap_bounds</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">DataExtractionError</span><span class="p">(</span>
                    <span class="s2">&quot;Could not clip input vector features to &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;snap raster bounds: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="c1"># make sure there are still features left</span>
        <span class="k">if</span> <span class="n">in_gdf</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataExtractionError</span><span class="p">(</span><span class="s2">&quot;Seems there are no features to convert&quot;</span><span class="p">)</span>

        <span class="c1"># infer shape and affine of the resulting raster grid if not provided</span>
        <span class="n">increment</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">snap_bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">in_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span><span class="o">.</span><span class="n">issubset</span><span class="p">({</span><span class="s2">&quot;Polygon&quot;</span><span class="p">,</span> <span class="s2">&quot;MultiPolygon&quot;</span><span class="p">}):</span>
                <span class="n">minx</span> <span class="o">=</span> <span class="n">in_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">minx</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                <span class="n">maxx</span> <span class="o">=</span> <span class="n">in_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">maxx</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                <span class="n">miny</span> <span class="o">=</span> <span class="n">in_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">miny</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                <span class="n">maxy</span> <span class="o">=</span> <span class="n">in_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">maxy</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">minx</span> <span class="o">=</span> <span class="n">in_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                <span class="n">maxx</span> <span class="o">=</span> <span class="n">in_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                <span class="n">miny</span> <span class="o">=</span> <span class="n">in_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                <span class="n">maxy</span> <span class="o">=</span> <span class="n">in_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">snap_bounds</span> <span class="o">=</span> <span class="n">box</span><span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">)</span>
            <span class="n">increment</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span> <span class="o">=</span> <span class="n">snap_bounds</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">bounds</span>

        <span class="c1"># calculate number of columns from bounding box of all features</span>
        <span class="c1"># always round to the next bigger integer value to make sure no</span>
        <span class="c1"># value gets lost</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">abs</span><span class="p">((</span><span class="n">maxy</span> <span class="o">-</span> <span class="n">miny</span><span class="p">)</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">geo_info</span><span class="o">.</span><span class="n">pixres_y</span><span class="p">))))</span> <span class="o">+</span> <span class="n">increment</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">abs</span><span class="p">((</span><span class="n">maxx</span> <span class="o">-</span> <span class="n">minx</span><span class="p">)</span> <span class="o">/</span> <span class="n">geo_info</span><span class="o">.</span><span class="n">pixres_x</span><span class="p">)))</span> <span class="o">+</span> <span class="n">increment</span>
        <span class="n">snap_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">)</span>

        <span class="c1"># check pixel data model</span>
        <span class="n">area_or_point</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;area_or_point&quot;</span><span class="p">,</span> <span class="s2">&quot;Area&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">area_or_point</span> <span class="o">==</span> <span class="s2">&quot;Point&quot;</span><span class="p">:</span>
            <span class="n">minx</span> <span class="o">=</span> <span class="n">minx</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">geo_info</span><span class="o">.</span><span class="n">pixres_x</span>
            <span class="n">maxy</span> <span class="o">=</span> <span class="n">maxy</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">geo_info</span><span class="o">.</span><span class="n">pixres_y</span>

        <span class="c1"># update and create new GeoInfo instance</span>
        <span class="n">geo_info</span> <span class="o">=</span> <span class="n">GeoInfo</span><span class="p">(</span>
            <span class="n">epsg</span><span class="o">=</span><span class="n">in_gdf</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">to_epsg</span><span class="p">(),</span>
            <span class="n">ulx</span><span class="o">=</span><span class="n">minx</span><span class="p">,</span>
            <span class="n">uly</span><span class="o">=</span><span class="n">maxy</span><span class="p">,</span>
            <span class="n">pixres_x</span><span class="o">=</span><span class="n">geo_info</span><span class="o">.</span><span class="n">pixres_x</span><span class="p">,</span>
            <span class="n">pixres_y</span><span class="o">=</span><span class="n">geo_info</span><span class="o">.</span><span class="n">pixres_y</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># rasterize the vector features. Point features work in another way</span>
        <span class="c1"># than Polygons</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">in_gdf</span><span class="o">.</span><span class="n">geom_type</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;Point&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">rasterized</span> <span class="o">=</span> <span class="n">array_from_points</span><span class="p">(</span>
                    <span class="n">gdf</span><span class="o">=</span><span class="n">in_gdf</span><span class="p">,</span>
                    <span class="n">band_name_src</span><span class="o">=</span><span class="n">band_name_src</span><span class="p">,</span>
                    <span class="n">pixres_x</span><span class="o">=</span><span class="n">geo_info</span><span class="o">.</span><span class="n">pixres_x</span><span class="p">,</span>
                    <span class="n">pixres_y</span><span class="o">=</span><span class="n">geo_info</span><span class="o">.</span><span class="n">pixres_y</span><span class="p">,</span>
                    <span class="n">nodata_dst</span><span class="o">=</span><span class="n">nodata_dst</span><span class="p">,</span>
                    <span class="n">dtype_src</span><span class="o">=</span><span class="n">dtype_src</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;Could not process POINT attribute &quot;</span><span class="si">{</span><span class="n">band_name_src</span><span class="si">}</span><span class="s1">&quot;: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">shapes</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">geom</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                        <span class="n">in_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">in_gdf</span><span class="p">[</span><span class="n">band_name_src</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype_src</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">rasterized</span> <span class="o">=</span> <span class="n">features</span><span class="o">.</span><span class="n">rasterize</span><span class="p">(</span>
                    <span class="n">shapes</span><span class="o">=</span><span class="n">shapes</span><span class="p">,</span>
                    <span class="n">out_shape</span><span class="o">=</span><span class="n">snap_shape</span><span class="p">,</span>
                    <span class="n">transform</span><span class="o">=</span><span class="n">geo_info</span><span class="o">.</span><span class="n">as_affine</span><span class="p">(),</span>
                    <span class="n">all_touched</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">fill</span><span class="o">=</span><span class="n">nodata_dst</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">dtype_src</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;Could not process MULTI/POLYGON attribute &quot;</span><span class="si">{</span><span class="n">band_name_src</span><span class="si">}</span><span class="s1">&quot;: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="p">)</span>

        <span class="c1"># initialize new Band instance</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">band_name</span><span class="o">=</span><span class="n">band_name_dst</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="n">rasterized</span><span class="p">,</span>
            <span class="n">geo_info</span><span class="o">=</span><span class="n">geo_info</span><span class="p">,</span>
            <span class="n">nodata</span><span class="o">=</span><span class="n">nodata_dst</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Band.read_pixels"><a class="viewcode-back" href="../../../packages/eodal.core.band.html#eodal.core.band.Band.read_pixels">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read_pixels</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">fpath_raster</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span>
        <span class="n">vector_features</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Path</span><span class="p">,</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">],</span>
        <span class="n">band_idx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">band_name_src</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">band_name_dst</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;B1&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads single pixel values from a raster dataset into a ``GeoDataFrame``</span>

<span class="sd">        NOTE:</span>
<span class="sd">            The pixels to read are defined by a ``GeoDataFrame`` or file with</span>
<span class="sd">            vector features understood by ``fiona``. If the geometry type is not</span>
<span class="sd">            ``Point`` the centroids will be used for extracting the closest</span>
<span class="sd">            grid cell value.</span>

<span class="sd">        :param fpath_raster:</span>
<span class="sd">            file-path to the raster dataset from which to extract pixel values</span>
<span class="sd">        :param vector_features:</span>
<span class="sd">            file-path or ``GeoDataFrame`` to features defining the pixels to read</span>
<span class="sd">            from a raster dataset. The geometries can be of type ``Point``,</span>
<span class="sd">            ``Polygon`` or ``MultiPolygon``. In the latter two cases the centroids</span>
<span class="sd">            are used to extract pixel values, whereas for point features the</span>
<span class="sd">            closest raster grid cell is selected.</span>
<span class="sd">        :param band_idx:</span>
<span class="sd">            band index of the raster band to read (starting with 1). If not</span>
<span class="sd">            provided the first band will be always read. Ignored if</span>
<span class="sd">            `band_name_src` is provided.</span>
<span class="sd">        :param band_name_src:</span>
<span class="sd">            instead of providing a band index to read (`band_idx`) a band name</span>
<span class="sd">            can be passed. If provided `band_idx` is ignored. NOTE: This works</span>
<span class="sd">            *only* if the raster dataset has band names set in its descriptions</span>
<span class="sd">            (often not the case)!</span>
<span class="sd">        :param band_name_dst:</span>
<span class="sd">            name of the raster band in the resulting ``GeoDataFrame`` (i.e.,</span>
<span class="sd">            column name)</span>
<span class="sd">        :returns:</span>
<span class="sd">            ``GeoDataFrame`` with extracted pixel values. If the vector features</span>
<span class="sd">            defining the sampling points are not within the spatial extent of the</span>
<span class="sd">            raster dataset the pixel values are set to nodata (inferred from</span>
<span class="sd">            the raster source)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check input point features</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_pixel_geometries</span><span class="p">(</span>
            <span class="n">vector_features</span><span class="o">=</span><span class="n">vector_features</span><span class="p">,</span> <span class="n">fpath_raster</span><span class="o">=</span><span class="n">fpath_raster</span>
        <span class="p">)</span>

        <span class="c1"># use rasterio.sample to extract the pixel values from the raster</span>
        <span class="c1"># to do so, we need a list of coordinate tuples</span>
        <span class="n">coord_list</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">y</span><span class="p">)]</span>
        <span class="k">with</span> <span class="n">rio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fpath_raster</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
            <span class="c1"># overwrite band_idx if band_name_src is provided and band names</span>
            <span class="c1"># is not None (otherwise the band index cannot be determined)</span>
            <span class="n">band_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">descriptions</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">band_names</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="kc">None</span><span class="p">}:</span>
                <span class="k">if</span> <span class="n">band_name_src</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">band_name_src</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">band_names</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">BandNotFoundError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s1">&#39;Could not find band &quot;</span><span class="si">{</span><span class="n">band_name_src</span><span class="si">}</span><span class="s1">&quot; &#39;</span>
                            <span class="sa">f</span><span class="s2">&quot;in </span><span class="si">{</span><span class="n">fpath_raster</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                    <span class="n">band_idx</span> <span class="o">=</span> <span class="n">band_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">band_name_src</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># yield all values from the generator</span>
                <span class="k">def</span> <span class="nf">_sample</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">coord_list</span><span class="p">,</span> <span class="n">band_idx</span><span class="p">):</span>
                    <span class="k">yield from</span> <span class="n">src</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">coord_list</span><span class="p">,</span> <span class="n">band_idx</span><span class="p">)</span>

                <span class="n">pixel_samples</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_sample</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">coord_list</span><span class="p">,</span> <span class="n">band_idx</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Extraction of pixels from raster failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># append the extracted pixels to the exisiting geodataframe. We can do</span>
        <span class="c1"># so, because we have passed the pixels in the same order as they occur</span>
        <span class="c1"># in the dataframe</span>
        <span class="n">band_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pixel_samples</span><span class="p">]</span>
        <span class="n">gdf</span><span class="p">[</span><span class="n">band_name_dst</span><span class="p">]</span> <span class="o">=</span> <span class="n">band_list</span>

        <span class="k">return</span> <span class="n">gdf</span></div>

    <span class="k">def</span> <span class="nf">_flatten_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Flattens band coordinates. To be used when converting an array to</span>
<span class="sd">        ``geopandas.GeoDataFrame``.</span>

<span class="sd">        :returns:</span>
<span class="sd">            dictionary of ``numpy.ndarray`` containing the x and y</span>
<span class="sd">            coordinates in flattened format to match the flattened band</span>
<span class="sd">            values in ``Fortran`` order</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get coordinates</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span>
        <span class="c1"># flatten x coordinates along the y-axis</span>
        <span class="n">flat_x_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">)</span>
        <span class="c1"># flatten y coordinates along the x-axis</span>
        <span class="n">flat_y_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="p">)</span>

        <span class="n">out_coords</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">flat_x_coords</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="n">flat_y_coords</span><span class="p">}</span>

        <span class="k">return</span> <span class="n">out_coords</span>

<div class="viewcode-block" id="Band.copy"><a class="viewcode-back" href="../../../packages/eodal.core.band.html#eodal.core.band.Band.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of the current ``Band`` instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Band</span><span class="p">(</span><span class="o">**</span><span class="n">attrs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Band.clip"><a class="viewcode-back" href="../../../packages/eodal.core.band.html#eodal.core.band.Band.clip">[docs]</a>    <span class="k">def</span> <span class="nf">clip</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">clipping_bounds</span><span class="p">:</span> <span class="n">Path</span>
        <span class="o">|</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span>
        <span class="o">|</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoSeries</span>
        <span class="o">|</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
        <span class="o">|</span> <span class="n">Polygon</span>
        <span class="o">|</span> <span class="n">MultiPolygon</span><span class="p">,</span>
        <span class="n">full_bounding_box_only</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clip a band object to a geometry or the bounding box of one or more</span>
<span class="sd">        geometries. By default, pixel values outside the geometry are masked.</span>
<span class="sd">        The spatial extent of the returned `Band` instance is **always** cropped</span>
<span class="sd">        to the bounding box of the geomtry/ geometries.</span>

<span class="sd">        NOTE:</span>
<span class="sd">            When passing a `GeoDataFrame` with more than one feature, the single</span>
<span class="sd">            feature geometries are dissolved into a single one!</span>

<span class="sd">        :param clipping_bounds:</span>
<span class="sd">            spatial bounds to clip the Band to. Can be either a vector file, a shapely</span>
<span class="sd">            `Polygon` or `MultiPolygon`, a `GeoDataFrame`, `GeoSeries` or a coordinate</span>
<span class="sd">            tuple with (xmin, ymin, xmax, ymax).</span>
<span class="sd">            Vector files and `GeoDataFrame` are reprojected into the bands&#39; coordinate</span>
<span class="sd">            system if required, while the coordinate tuple and shapely geometry **MUST**</span>
<span class="sd">            be provided in the CRS of the band.</span>
<span class="sd">        :param full_bounding_box_only:</span>
<span class="sd">            if False (default), clips to the bounding box of the geometry and masks</span>
<span class="sd">            values outside the actual geometry boundaries. To obtain all values within</span>
<span class="sd">            the bounding box set to True.</span>
<span class="sd">            .. versionadded:: 0.1.1</span>
<span class="sd">        :param inplace:</span>
<span class="sd">            if False (default) returns a copy of the ``Band`` instance</span>
<span class="sd">            with the changes applied. If True overwrites the values</span>
<span class="sd">            in the current instance.</span>
<span class="sd">        :returns:</span>
<span class="sd">            clipped band instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># prepare geometries</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clipping_bounds</span><span class="p">,</span> <span class="n">Path</span><span class="p">):</span>
            <span class="n">clipping_bounds</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">clipping_bounds</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clipping_bounds</span><span class="p">,</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoSeries</span><span class="p">):</span>
            <span class="n">clipping_bounds</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">geometry</span><span class="o">=</span><span class="n">clipping_bounds</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clipping_bounds</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clipping_bounds</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected four coordinates (xmin, ymin, xmax, ymax)&quot;</span><span class="p">)</span>
            <span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">clipping_bounds</span>
            <span class="n">clipping_bounds</span> <span class="o">=</span> <span class="n">box</span><span class="p">(</span><span class="o">*</span><span class="n">clipping_bounds</span><span class="p">)</span>

        <span class="c1"># get bounding box</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clipping_bounds</span><span class="p">,</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">):</span>
            <span class="c1"># reproject GeoDataFrame if necessary</span>
            <span class="n">_clipping_bounds</span> <span class="o">=</span> <span class="n">clipping_bounds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">_clipping_bounds</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_info</span><span class="o">.</span><span class="n">epsg</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># get the bounding box of the FIRST feature</span>
            <span class="n">_clipping_bounds_boundaries</span> <span class="o">=</span> <span class="n">_clipping_bounds</span><span class="o">.</span><span class="n">bounds</span>
            <span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">_clipping_bounds_boundaries</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># the actual geometries are dissolved in case there is more than one record</span>
            <span class="c1"># and converted to a shapely object</span>
            <span class="n">actual_geom</span> <span class="o">=</span> <span class="n">_clipping_bounds</span><span class="o">.</span><span class="n">dissolve</span><span class="p">()</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clipping_bounds</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">clipping_bounds</span><span class="p">,</span> <span class="n">MultiPolygon</span>
        <span class="p">):</span>
            <span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">clipping_bounds</span><span class="o">.</span><span class="n">bounds</span>
            <span class="n">actual_geom</span> <span class="o">=</span> <span class="n">clipping_bounds</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">clipping_bounds</span><span class="p">)</span><span class="si">}</span><span class="s2"> is not supported&quot;</span><span class="p">)</span>

        <span class="c1"># make sure xmax and xmin as well as ymax and ymin are not the same</span>
        <span class="k">if</span> <span class="n">xmax</span> <span class="o">==</span> <span class="n">xmin</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot handle extent of zero length in x direction&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ymax</span> <span class="o">==</span> <span class="n">ymin</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot handle extent of zero length in y direction&quot;</span><span class="p">)</span>

        <span class="c1"># actual clipping operation. Calculate the rows and columns where to clip</span>
        <span class="c1"># the band</span>
        <span class="n">clip_shape</span> <span class="o">=</span> <span class="n">box</span><span class="p">(</span><span class="n">minx</span><span class="o">=</span><span class="n">xmin</span><span class="p">,</span> <span class="n">miny</span><span class="o">=</span><span class="n">ymin</span><span class="p">,</span> <span class="n">maxx</span><span class="o">=</span><span class="n">xmax</span><span class="p">,</span> <span class="n">maxy</span><span class="o">=</span><span class="n">ymax</span><span class="p">)</span>
        <span class="c1"># check for overlap first</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="n">clip_shape</span><span class="o">.</span><span class="n">overlaps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">covers</span><span class="p">(</span><span class="n">clip_shape</span><span class="p">)</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">clip_shape</span><span class="p">)</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">overlaps</span><span class="p">(</span><span class="n">clip_shape</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">clip_shape</span><span class="o">.</span><span class="n">covers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Clipping bounds do not overlap Band&quot;</span><span class="p">)</span>
        <span class="c1"># then determine the extent in image coordinates by search for the closest image</span>
        <span class="c1"># pixels</span>
        <span class="n">row_start</span><span class="p">,</span> <span class="n">row_stop</span><span class="p">,</span> <span class="n">col_start</span><span class="p">,</span> <span class="n">col_stop</span> <span class="o">=</span> <span class="n">bounds_window</span><span class="p">(</span>
            <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span><span class="p">),</span> <span class="n">affine</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_info</span><span class="o">.</span><span class="n">as_affine</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="c1"># adopt bounds if clip shape is larger than the Band&#39;s spatial extent</span>
        <span class="k">if</span> <span class="n">row_start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">row_start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">row_stop</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">:</span>
            <span class="n">row_stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span>
        <span class="k">if</span> <span class="n">col_start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">col_start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">col_start</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="p">:</span>
            <span class="n">col_stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncols</span>

        <span class="c1"># get upper left coordinate tuple</span>
        <span class="n">ulx</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_info</span><span class="o">.</span><span class="n">as_affine</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">col_start</span><span class="p">,</span> <span class="n">row_stop</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">uly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_info</span><span class="o">.</span><span class="n">as_affine</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">col_stop</span><span class="p">,</span> <span class="n">row_start</span><span class="p">)</span>

        <span class="c1"># get its GeoInfo and update it accordingly</span>
        <span class="n">geo_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_info</span>
        <span class="n">new_geo_info</span> <span class="o">=</span> <span class="n">GeoInfo</span><span class="p">(</span>
            <span class="n">epsg</span><span class="o">=</span><span class="n">geo_info</span><span class="o">.</span><span class="n">epsg</span><span class="p">,</span>
            <span class="n">ulx</span><span class="o">=</span><span class="n">ulx</span><span class="p">,</span>
            <span class="n">uly</span><span class="o">=</span><span class="n">uly</span><span class="p">,</span>
            <span class="n">pixres_x</span><span class="o">=</span><span class="n">geo_info</span><span class="o">.</span><span class="n">pixres_x</span><span class="p">,</span>
            <span class="n">pixres_y</span><span class="o">=</span><span class="n">geo_info</span><span class="o">.</span><span class="n">pixres_y</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_values</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">row_start</span><span class="p">:</span><span class="n">row_stop</span><span class="p">,</span> <span class="n">col_start</span><span class="p">:</span><span class="n">col_stop</span><span class="p">]</span>

        <span class="c1"># if full_bounding_box is False, mask out pixels not overlapping the</span>
        <span class="c1"># geometry (but located within the bounding box)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">full_bounding_box_only</span><span class="p">:</span>
            <span class="c1"># to mask pixels outside the geometry we need to rasterize it</span>
            <span class="c1"># Rasterize vector using the shape and coordinate system of the raster</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">features</span><span class="o">.</span><span class="n">rasterize</span><span class="p">(</span>
                <span class="p">[</span><span class="n">actual_geom</span><span class="p">],</span>
                <span class="n">out_shape</span><span class="o">=</span><span class="n">new_values</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                <span class="n">fill</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">transform</span><span class="o">=</span><span class="n">new_geo_info</span><span class="o">.</span><span class="n">as_affine</span><span class="p">(),</span>
                <span class="n">all_touched</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">default_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;uint8&quot;</span><span class="p">,</span>
            <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">new_values</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;values&quot;</span><span class="p">,</span> <span class="n">new_values</span><span class="p">)</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;geo_info&quot;</span><span class="p">,</span> <span class="n">new_geo_info</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;values&quot;</span><span class="p">:</span> <span class="n">new_values</span><span class="p">,</span> <span class="s2">&quot;geo_info&quot;</span><span class="p">:</span> <span class="n">new_geo_info</span><span class="p">})</span>
            <span class="k">return</span> <span class="n">Band</span><span class="p">(</span><span class="o">**</span><span class="n">attrs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Band.get_attributes"><a class="viewcode-back" href="../../../packages/eodal.core.band.html#eodal.core.band.Band.get_attributes">[docs]</a>    <span class="k">def</span> <span class="nf">get_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns raster data attributes in ``rasterio`` compatible way</span>

<span class="sd">        :param kwargs:</span>
<span class="sd">            key-word arguments to insert into the raster attributes</span>
<span class="sd">        :returns:</span>
<span class="sd">            dictionary compatible with ``rasterio`` attributes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;is_tiled&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_tiled</span>
        <span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;nodatavals&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodata</span><span class="p">,)</span>
        <span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;scales&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,)</span>
        <span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;offsets&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">,)</span>
        <span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;descriptions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">band_alias</span><span class="p">,)</span>
        <span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;crs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_info</span><span class="o">.</span><span class="n">epsg</span>
        <span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;transform&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">)</span>
        <span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">,)</span>
        <span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">attrs</span></div>

<div class="viewcode-block" id="Band.get_meta"><a class="viewcode-back" href="../../../packages/eodal.core.band.html#eodal.core.band.Band.get_meta">[docs]</a>    <span class="k">def</span> <span class="nf">get_meta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">driver</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;gTiff&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a ``rasterio`` compatible dictionary with raster dataset</span>
<span class="sd">        metadata.</span>

<span class="sd">        :param driver:</span>
<span class="sd">            name of the ``rasterio`` driver. `gTiff` (GeoTiff) by default</span>
<span class="sd">        :param kwargs:</span>
<span class="sd">            additional keyword arguments to append to metadata dictionary</span>
<span class="sd">            or to overwrite defaults such as the &quot;compress&quot; attribute.</span>
<span class="sd">        :returns:</span>
<span class="sd">            ``rasterio`` compatible metadata dictionary to be used for</span>
<span class="sd">            writing new raster datasets</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># set defaults</span>
        <span class="n">meta</span><span class="p">[</span><span class="s2">&quot;height&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span>
        <span class="n">meta</span><span class="p">[</span><span class="s2">&quot;width&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncols</span>
        <span class="n">meta</span><span class="p">[</span><span class="s2">&quot;crs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span>
        <span class="n">meta</span><span class="p">[</span><span class="s2">&quot;dtype&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">meta</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">meta</span><span class="p">[</span><span class="s2">&quot;nodata&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodata</span>
        <span class="n">meta</span><span class="p">[</span><span class="s2">&quot;transform&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span>
        <span class="n">meta</span><span class="p">[</span><span class="s2">&quot;is_tile&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_tiled</span>
        <span class="n">meta</span><span class="p">[</span><span class="s2">&quot;driver&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">driver</span>
        <span class="c1"># &quot;compress&quot; as suggested here:</span>
        <span class="c1"># https://github.com/rasterio/rasterio/discussions/2933#discussioncomment-7208578</span>
        <span class="n">meta</span><span class="p">[</span><span class="s2">&quot;compress&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;DEFLATE&quot;</span>

        <span class="c1"># defaults can be overwritten using custom kwargs</span>
        <span class="n">meta</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">meta</span></div>

<div class="viewcode-block" id="Band.get_pixels"><a class="viewcode-back" href="../../../packages/eodal.core.band.html#eodal.core.band.Band.get_pixels">[docs]</a>    <span class="k">def</span> <span class="nf">get_pixels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector_features</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Path</span><span class="p">,</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns pixel values from a ``Band`` instance raster values.</span>

<span class="sd">        The extracted band array values are stored in a new column in the</span>
<span class="sd">        returned `vector_features` ``GeoDataFrame`` named like the name</span>
<span class="sd">        of the band.</span>

<span class="sd">        If you do not want to read the entire raster data first consider</span>
<span class="sd">        using `~eodal.core.Band.read_pixels` instead.</span>

<span class="sd">        NOTE:</span>
<span class="sd">            Masked pixels are set to the band&#39;s nodata value.</span>

<span class="sd">        :param vector_features:</span>
<span class="sd">            file-path or ``GeoDataFrame`` to features defining the pixels to read</span>
<span class="sd">            from the ``Band`` raster values. The geometries can be of type ``Point``,</span>
<span class="sd">            ``Polygon`` or ``MultiPolygon``. In the latter two cases the centroids</span>
<span class="sd">            are used to extract pixel values, whereas for point features the</span>
<span class="sd">            closest raster grid cell is selected.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get pixel point features</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_pixel_geometries</span><span class="p">(</span>
            <span class="n">vector_features</span><span class="o">=</span><span class="n">vector_features</span><span class="p">,</span> <span class="n">raster_crs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span>
        <span class="p">)</span>

        <span class="c1"># drop points outside of the band&#39;s bounding box (speeds up the process)</span>
        <span class="n">band_bbox</span> <span class="o">=</span> <span class="n">BoundingBox</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">cx</span><span class="p">[</span><span class="n">band_bbox</span><span class="o">.</span><span class="n">left</span> <span class="p">:</span> <span class="n">band_bbox</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">band_bbox</span><span class="o">.</span><span class="n">bottom</span> <span class="p">:</span> <span class="n">band_bbox</span><span class="o">.</span><span class="n">top</span><span class="p">]</span>

        <span class="c1"># define helper function for getting the closest array index for a coordinate</span>
        <span class="c1"># map the coordinates to array indices</span>
        <span class="k">def</span> <span class="nf">_find_nearest_array_index</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">array</span> <span class="o">-</span> <span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>

        <span class="c1"># calculate the x and y array indices required to extract the pixel values</span>
        <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span>
        <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">y</span>

        <span class="c1"># get band coordinates</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span>

        <span class="c1"># get column (x) indices</span>
        <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;col&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">find_nearest_array_index</span><span class="o">=</span><span class="n">_find_nearest_array_index</span><span class="p">:</span>
            <span class="n">find_nearest_array_index</span><span class="p">(</span>
                <span class="n">coords</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">x</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># get row (y) indices</span>
        <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;row&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">y</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">find_nearest_array_index</span><span class="o">=</span><span class="n">_find_nearest_array_index</span><span class="p">:</span>
            <span class="n">find_nearest_array_index</span><span class="p">(</span>
                <span class="n">coords</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="n">y</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># add column to store band values</span>
        <span class="n">gdf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">band_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># loop over sample points and add them as new entries to the GeoDataFrame</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="c1"># get array value for the current column and row, continue on out-of-bounds</span>
            <span class="c1"># error</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">array_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">record</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">record</span><span class="o">.</span><span class="n">col</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># ignore masked pixels</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_masked_array</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">record</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">record</span><span class="o">.</span><span class="n">col</span><span class="p">]:</span>
                    <span class="n">array_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodata</span>
            <span class="n">gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                <span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">row</span> <span class="o">==</span> <span class="n">record</span><span class="o">.</span><span class="n">row</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">col</span> <span class="o">==</span> <span class="n">record</span><span class="o">.</span><span class="n">col</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_name</span>
            <span class="p">]</span> <span class="o">=</span> <span class="n">array_value</span>

        <span class="c1"># clean up GeoDataFrame</span>
        <span class="n">cols_to_drop</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;row&quot;</span><span class="p">,</span> <span class="s2">&quot;col&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">col_to_drop</span> <span class="ow">in</span> <span class="n">cols_to_drop</span><span class="p">:</span>
            <span class="n">gdf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">col_to_drop</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">gdf</span></div>

<div class="viewcode-block" id="Band.hist"><a class="viewcode-back" href="../../../packages/eodal.core.band.html#eodal.core.band.Band.hist">[docs]</a>    <span class="k">def</span> <span class="nf">hist</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ax</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Axes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ylabel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">xlabel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fontsize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Figure</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the raster histogram using ``matplotlib``</span>

<span class="sd">        :param nbins:</span>
<span class="sd">            optional number of histogram bins</span>
<span class="sd">        :param ax:</span>
<span class="sd">            optional `matplotlib.axes` object to plot onto</span>
<span class="sd">        :param ylabel:</span>
<span class="sd">            optional y axis label</span>
<span class="sd">        :param xlabel:</span>
<span class="sd">            optional x axis label</span>
<span class="sd">        :param fontsize:</span>
<span class="sd">            fontsize to use for axes labels, plot title and colorbar label.</span>
<span class="sd">            12 pts by default.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># open figure and axes for plotting</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">clear</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># or get figure from existing axis object passed</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_figure</span><span class="p">()</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">vals</span><span class="p">)],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xlabel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xlabel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_name</span>
        <span class="k">if</span> <span class="n">ylabel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ylabel</span> <span class="o">=</span> <span class="s2">&quot;Frequency&quot;</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">xlabel</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span></div>

<div class="viewcode-block" id="Band.plot"><a class="viewcode-back" href="../../../packages/eodal.core.band.html#eodal.core.band.Band.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">colormap</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;viridis&quot;</span><span class="p">,</span>
        <span class="n">discrete_values</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">user_defined_colors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListedColormap</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">user_defined_ticks</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">colorbar_label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">vmin</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">vmax</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fontsize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
        <span class="n">ax</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Axes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Figure</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the raster values using ``matplotlib``</span>

<span class="sd">        :param colormap:</span>
<span class="sd">            String identifying one of matplotlib&#39;s colormaps.</span>
<span class="sd">            The default will plot the band using the viridis colormap.</span>
<span class="sd">        :param discrete_values:</span>
<span class="sd">            if True (Default) assumes that the band has continuous values</span>
<span class="sd">            (i.e., ordinary spectral data). If False assumes that the</span>
<span class="sd">            data only takes a limited set of discrete values (e.g., in case</span>
<span class="sd">            of a classification or mask layer).</span>
<span class="sd">        :param user_defined_colors:</span>
<span class="sd">            possibility to pass a custom, i.e., user-created color map object</span>
<span class="sd">            not part of the standard matplotlib color maps. If passed, the</span>
<span class="sd">            ``colormap`` argument is ignored.</span>
<span class="sd">        :param user_defined_ticks:</span>
<span class="sd">            list of ticks to overwrite matplotlib derived defaults (optional).</span>
<span class="sd">        :param colorbar_label:</span>
<span class="sd">            optional text label to set to the colorbar.</span>
<span class="sd">        :param vmin:</span>
<span class="sd">            lower value to use for `~matplotlib.pyplot.imshow()`. If None it</span>
<span class="sd">            is set to the lower 5% percentile of the data to plot.</span>
<span class="sd">        :param vmin:</span>
<span class="sd">            upper value to use for `~matplotlib.pyplot.imshow()`. If None it</span>
<span class="sd">            is set to the upper 95% percentile of the data to plot.</span>
<span class="sd">        :param fontsize:</span>
<span class="sd">            fontsize to use for axes labels, plot title and colorbar label.</span>
<span class="sd">            12 pts by default.</span>
<span class="sd">        :param ax:</span>
<span class="sd">            optional `matplotlib.axes` object to plot onto</span>
<span class="sd">        :returns:</span>
<span class="sd">            matplotlib figure object with the band data</span>
<span class="sd">            plotted as map</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the bounds of the band</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">BoundingBox</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>

        <span class="c1"># determine intervals for plotting and aspect ratio (figsize)</span>
        <span class="n">east_west_dim</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">right</span> <span class="o">-</span> <span class="n">bounds</span><span class="o">.</span><span class="n">left</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">east_west_dim</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="p">:</span>
            <span class="n">x_interval</span> <span class="o">=</span> <span class="mi">500</span>
        <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">east_west_dim</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">5000</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">east_west_dim</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="p">:</span>
            <span class="n">x_interval</span> <span class="o">=</span> <span class="mi">5000</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x_interval</span> <span class="o">=</span> <span class="mi">50000</span>
        <span class="n">north_south_dim</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">top</span> <span class="o">-</span> <span class="n">bounds</span><span class="o">.</span><span class="n">bottom</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">north_south_dim</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="p">:</span>
            <span class="n">y_interval</span> <span class="o">=</span> <span class="mi">500</span>
        <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">north_south_dim</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">5000</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">north_south_dim</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="p">:</span>
            <span class="n">y_interval</span> <span class="o">=</span> <span class="mi">5000</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y_interval</span> <span class="o">=</span> <span class="mi">50000</span>

        <span class="n">w_h_ratio</span> <span class="o">=</span> <span class="n">figaspect</span><span class="p">(</span><span class="n">east_west_dim</span> <span class="o">/</span> <span class="n">north_south_dim</span><span class="p">)</span>

        <span class="c1"># open figure and axes for plotting</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span>
                <span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">w_h_ratio</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">clear</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        <span class="c1"># or get figure from existing axis object passed</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_figure</span><span class="p">()</span>

        <span class="c1"># get color-map</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">user_defined_colors</span>
        <span class="k">if</span> <span class="n">cmap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">colormaps</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">colormap</span><span class="p">)</span>

        <span class="c1"># check if data is continuous (spectral) or discrete (np.unit8)</span>
        <span class="k">if</span> <span class="n">discrete_values</span><span class="p">:</span>
            <span class="c1"># define the bins and normalize</span>
            <span class="n">unique_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">BoundaryNorm</span><span class="p">(</span><span class="n">unique_values</span><span class="p">,</span> <span class="n">cmap</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
                <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
                <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="n">bounds</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">bounds</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">bounds</span><span class="o">.</span><span class="n">bottom</span><span class="p">,</span> <span class="n">bounds</span><span class="o">.</span><span class="n">top</span><span class="p">],</span>
                <span class="n">interpolation</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span>  <span class="c1"># important, otherwise img will have speckle!</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># clip data for displaying to central 96% percentile</span>
            <span class="c1"># TODO: here seems to be a bug with nans in the data ...</span>
            <span class="k">if</span> <span class="n">vmin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">vmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanquantile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">vmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanquantile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="mf">0.98</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">vmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

            <span class="c1"># actual displaying of the band data</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span>
                <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span>
                <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="n">bounds</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">bounds</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">bounds</span><span class="o">.</span><span class="n">bottom</span><span class="p">,</span> <span class="n">bounds</span><span class="o">.</span><span class="n">top</span><span class="p">],</span>
                <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># add colorbar (does not apply in RGB case)</span>
        <span class="k">if</span> <span class="n">colormap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
            <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;5%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">discrete_values</span><span class="p">:</span>
                <span class="n">cb</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span>
                    <span class="n">img</span><span class="p">,</span>
                    <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">,</span>
                    <span class="n">orientation</span><span class="o">=</span><span class="s2">&quot;vertical&quot;</span><span class="p">,</span>
                    <span class="n">ticks</span><span class="o">=</span><span class="n">unique_values</span><span class="p">,</span>
                    <span class="n">extend</span><span class="o">=</span><span class="s2">&quot;max&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cb</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s2">&quot;vertical&quot;</span><span class="p">)</span>
            <span class="c1"># overwrite ticker if user defined ticks provided</span>
            <span class="k">if</span> <span class="n">user_defined_ticks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># TODO: there seems to be one tick missing (?)</span>
                <span class="n">cb</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">locator_params</span><span class="p">(</span><span class="n">nbins</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">user_defined_ticks</span><span class="p">))</span>
                <span class="n">cb</span><span class="o">.</span><span class="n">set_ticklabels</span><span class="p">(</span><span class="n">user_defined_ticks</span><span class="p">)</span>
            <span class="c1"># add colorbar label text if provided</span>
            <span class="k">if</span> <span class="n">colorbar_label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cb</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span>
                    <span class="n">colorbar_label</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">270</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">,</span> <span class="n">labelpad</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">0.5</span>
                <span class="p">)</span>

        <span class="n">title_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_name</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_alias</span><span class="p">:</span>
            <span class="n">title_str</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">alias</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="n">title_str</span><span class="p">)</span>
        <span class="c1"># add axes labels and format ticker</span>
        <span class="n">epsg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_info</span><span class="o">.</span><span class="n">epsg</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">is_geographic</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="s2">&quot;deg&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">is_projected</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="s2">&quot;m&quot;</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;X [</span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">] (EPSG:</span><span class="si">{</span><span class="n">epsg</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">bounds</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">bounds</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">x_interval</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Y [</span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">] (EPSG:</span><span class="si">{</span><span class="n">epsg</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">bounds</span><span class="o">.</span><span class="n">bottom</span><span class="p">,</span> <span class="n">bounds</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="n">y_interval</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_major_formatter</span><span class="p">(</span><span class="n">ticker</span><span class="o">.</span><span class="n">FormatStrFormatter</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%.0f</span><span class="s2">&quot;</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_major_formatter</span><span class="p">(</span><span class="n">ticker</span><span class="o">.</span><span class="n">FormatStrFormatter</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%.0f</span><span class="s2">&quot;</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">fig</span></div>

<div class="viewcode-block" id="Band.mask"><a class="viewcode-back" href="../../../packages/eodal.core.band.html#eodal.core.band.Band.mask">[docs]</a>    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">inplace</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mask out pixels based on a boolean array.</span>

<span class="sd">        NOTE:</span>
<span class="sd">            If the band is already masked, the new mask updates the</span>
<span class="sd">            existing one. I.e., pixels already masked before remain</span>
<span class="sd">            masked.</span>

<span class="sd">        :param mask:</span>
<span class="sd">            ``numpy.ndarray`` of dtype ``boolean`` to use as mask.</span>
<span class="sd">            The mask must match the shape of the raster data.</span>
<span class="sd">        :param inplace:</span>
<span class="sd">            if False (default) returns a copy of the ``Band`` instance</span>
<span class="sd">            with the changes applied. If True overwrites the values</span>
<span class="sd">            in the current instance.</span>
<span class="sd">        :returns:</span>
<span class="sd">            ``Band`` instance if `inplace` is False, None instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check shape of mask passed and its dtype</span>
        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Mask must be boolean&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Shape of mask </span><span class="si">{</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> does not match &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;shape of band data </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># check if array is already masked</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_masked_array</span><span class="p">:</span>
            <span class="n">orig_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">mask</span>
            <span class="c1"># update the existing mask</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrows</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncols</span><span class="p">):</span>
                    <span class="c1"># ignore pixels already masked</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">orig_mask</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]:</span>
                        <span class="n">orig_mask</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span>
            <span class="c1"># re-use original fill value</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">fill_value</span>
            <span class="c1"># update band data array</span>
            <span class="n">masked_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                <span class="n">mask</span><span class="o">=</span><span class="n">orig_mask</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ndarray</span><span class="p">:</span>
            <span class="c1"># determine fill value from nodata value</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodata</span>
            <span class="n">masked_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_zarr</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;values&quot;</span><span class="p">,</span> <span class="n">masked_array</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;values&quot;</span><span class="p">:</span> <span class="n">masked_array</span><span class="p">})</span>
            <span class="k">return</span> <span class="n">Band</span><span class="p">(</span><span class="o">**</span><span class="n">attrs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Band.rename"><a class="viewcode-back" href="../../../packages/eodal.core.band.html#eodal.core.band.Band.rename">[docs]</a>    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">alias</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">autoupdate_alias</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets a new band name or alias</span>

<span class="sd">        :param name:</span>
<span class="sd">            new band name or alias</span>
<span class="sd">        :param alias:</span>
<span class="sd">            if False (defaults) renames the actual band name, otherwise changes</span>
<span class="sd">            the alias</span>
<span class="sd">        :param autoupdate_alias:</span>
<span class="sd">            if True (default) the band alias is set to the same value as the band</span>
<span class="sd">            name if `alias==False`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid name </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> - only non-empty strings are allowed&quot;</span>
            <span class="p">)</span>
        <span class="c1"># auto-update the band alias</span>
        <span class="k">if</span> <span class="n">alias</span> <span class="ow">or</span> <span class="n">autoupdate_alias</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;band_alias&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">alias</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;band_name&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Band.resample"><a class="viewcode-back" href="../../../packages/eodal.core.band.html#eodal.core.band.Band.resample">[docs]</a>    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target_resolution</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">interpolation_method</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">INTER_NEAREST_EXACT</span><span class="p">,</span>
        <span class="n">target_shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Changes the raster grid cell (pixel) size.</span>
<span class="sd">        Nodata pixels are not used for resampling.</span>

<span class="sd">        :param target_resolution:</span>
<span class="sd">            spatial resolution (grid cell size) in units of the spatial</span>
<span class="sd">            reference system. Applies to x and y direction.</span>
<span class="sd">        :param interpolation_method:</span>
<span class="sd">            opencv interpolation method. Per default nearest neighbor</span>
<span class="sd">            interpolation is used (`~cv2.INTER_NEAREST_EXACT`). See the</span>
<span class="sd">            `~cv2` documentation for a list of available methods.</span>
<span class="sd">        :param target_shape:</span>
<span class="sd">            shape of the output in terms of number of rows and columns.</span>
<span class="sd">            If None (default) the `target_shape` parameter is inferred</span>
<span class="sd">            from the band data. If you want to make sure the output is</span>
<span class="sd">            *aligned* with another raster band (co-registered) provide</span>
<span class="sd">            this parameter.</span>
<span class="sd">        :param inplace:</span>
<span class="sd">            if False (default) returns a copy of the ``Band`` instance</span>
<span class="sd">            with the changes applied. If True overwrites the values</span>
<span class="sd">            in the current instance.</span>
<span class="sd">        :returns:</span>
<span class="sd">            ``Band`` instance if `inplace` is False, None instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># resampling currently works on grids with identitical x and y</span>
        <span class="c1"># grid cell size only</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_info</span><span class="o">.</span><span class="n">pixres_x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_info</span><span class="o">.</span><span class="n">pixres_y</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Resampling currently supports regular grids only &quot;</span>
                <span class="s2">&quot;where the grid cell size is the same in x and y &quot;</span>
                <span class="s2">&quot;direction&quot;</span>
            <span class="p">)</span>

        <span class="c1"># if band has already the target resolution there&#39;s nothing to do</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_info</span><span class="o">.</span><span class="n">pixres_x</span><span class="p">)</span> <span class="o">==</span> <span class="n">target_resolution</span>
            <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_info</span><span class="o">.</span><span class="n">pixres_y</span><span class="p">)</span> <span class="o">==</span> <span class="n">target_resolution</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># check if a target shape is provided</span>
        <span class="k">if</span> <span class="n">target_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nrows_resampled</span> <span class="o">=</span> <span class="n">target_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ncols_resampled</span> <span class="o">=</span> <span class="n">target_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># if not determine the extent from the bounds</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">BoundingBox</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>
            <span class="c1"># calculate new size of the raster</span>
            <span class="n">ncols_resampled</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">bounds</span><span class="o">.</span><span class="n">right</span> <span class="o">-</span> <span class="n">bounds</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="n">target_resolution</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">nrows_resampled</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">bounds</span><span class="o">.</span><span class="n">top</span> <span class="o">-</span> <span class="n">bounds</span><span class="o">.</span><span class="n">bottom</span><span class="p">)</span> <span class="o">/</span> <span class="n">target_resolution</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">target_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">nrows_resampled</span><span class="p">,</span> <span class="n">ncols_resampled</span><span class="p">)</span>

        <span class="c1"># opencv2 switches the axes order!</span>
        <span class="n">dim_resampled</span> <span class="o">=</span> <span class="p">(</span><span class="n">ncols_resampled</span><span class="p">,</span> <span class="n">nrows_resampled</span><span class="p">)</span>

        <span class="c1"># check if the band data is stored in a masked array</span>
        <span class="c1"># if so, replace the masked values with NaN</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_masked_array</span><span class="p">:</span>
            <span class="n">band_data</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ndarray</span><span class="p">:</span>
            <span class="n">band_data</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_zarr</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

        <span class="n">scaling_factor</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_info</span><span class="o">.</span><span class="n">pixres_x</span> <span class="o">/</span> <span class="n">target_resolution</span><span class="p">)</span>
        <span class="n">blackfill_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodata</span>

        <span class="c1"># we have to take care about no-data pixels</span>
        <span class="n">valid_pixels</span> <span class="o">=</span> <span class="n">count_valid</span><span class="p">(</span><span class="n">in_array</span><span class="o">=</span><span class="n">band_data</span><span class="p">,</span> <span class="n">no_data_value</span><span class="o">=</span><span class="n">blackfill_value</span><span class="p">)</span>
        <span class="n">all_pixels</span> <span class="o">=</span> <span class="n">band_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">band_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># if all pixels are valid, then we can directly proceed to the resampling</span>
        <span class="k">if</span> <span class="n">valid_pixels</span> <span class="o">==</span> <span class="n">all_pixels</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span>
                    <span class="n">band_data</span><span class="p">,</span> <span class="n">dsize</span><span class="o">=</span><span class="n">dim_resampled</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation_method</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ResamplingFailedError</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># blackfill pixel should be set to NaN before resampling</span>
            <span class="n">type_casting</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">band_data</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span>
                <span class="s2">&quot;uint8&quot;</span><span class="p">,</span>
                <span class="s2">&quot;uint16&quot;</span><span class="p">,</span>
                <span class="s2">&quot;uint32&quot;</span><span class="p">,</span>
                <span class="s2">&quot;int8&quot;</span><span class="p">,</span>
                <span class="s2">&quot;int16&quot;</span><span class="p">,</span>
                <span class="s2">&quot;int32&quot;</span><span class="p">,</span>
                <span class="s2">&quot;int64&quot;</span><span class="p">,</span>
            <span class="p">]:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">band_data</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
                <span class="n">type_casting</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">band_data</span><span class="p">)</span>
            <span class="n">tmp</span><span class="p">[</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">blackfill_value</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="c1"># resample data</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span>
                    <span class="n">tmp</span><span class="p">,</span> <span class="n">dsize</span><span class="o">=</span><span class="n">dim_resampled</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation_method</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ResamplingFailedError</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

            <span class="c1"># in addition, run pixel division since there will be too many NaN pixels</span>
            <span class="c1"># when using only res from cv2 resize as it sets pixels without full</span>
            <span class="c1"># spatial context to NaN. This works, however, only if the target resolution</span>
            <span class="c1"># decreases the current pixel resolution by an integer scalar</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">res_pixel_div</span> <span class="o">=</span> <span class="n">upsample_array</span><span class="p">(</span>
                    <span class="n">in_array</span><span class="o">=</span><span class="n">band_data</span><span class="p">,</span> <span class="n">scaling_factor</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">scaling_factor</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">res_pixel_div</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># replace NaNs with values from pixel division (if possible); thus we will</span>
            <span class="c1"># get all pixel values and the correct blackfill</span>
            <span class="c1"># when working on spatial subsets this might fail because of shape</span>
            <span class="c1"># mismatches;</span>
            <span class="c1"># in this case keep the cv2 output, which means loosing a few pixels</span>
            <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">res_pixel_div</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="n">res</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">res</span><span class="p">)]</span> <span class="o">=</span> <span class="n">res_pixel_div</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">res</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">res</span><span class="p">)]</span> <span class="o">=</span> <span class="n">blackfill_value</span>

            <span class="c1"># cast back to original datatype if required</span>
            <span class="k">if</span> <span class="n">type_casting</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">band_data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># if the array is masked, resample the mask as well</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_masked_array</span><span class="p">:</span>
            <span class="c1"># convert bools to int8 (cv2 does not support boolean arrays)</span>
            <span class="n">in_mask</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;uint8&quot;</span><span class="p">)</span>
            <span class="n">out_mask</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">in_mask</span><span class="p">,</span> <span class="n">dim_resampled</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">INTER_NEAREST_EXACT</span><span class="p">)</span>
            <span class="c1"># convert mask back to boolean array</span>
            <span class="n">out_mask</span> <span class="o">=</span> <span class="n">out_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
            <span class="c1"># re-use fill value of the original array</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">fill_value</span>
            <span class="c1"># save as masked array</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">res</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">out_mask</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>

        <span class="c1"># update the geo_info with new pixel resolution. The upper left x and y</span>
        <span class="c1"># coordinate must be changed if the pixel coordinates refer to the center</span>
        <span class="c1"># of the pixel (AREA_OR_POINT == Point)</span>
        <span class="n">geo_info</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_info</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="n">geo_info</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;pixres_x&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_info</span><span class="o">.</span><span class="n">pixres_x</span><span class="p">)</span> <span class="o">*</span> <span class="n">target_resolution</span><span class="p">,</span>
                <span class="s2">&quot;pixres_y&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_info</span><span class="o">.</span><span class="n">pixres_y</span><span class="p">)</span> <span class="o">*</span> <span class="n">target_resolution</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">area_or_point</span> <span class="o">==</span> <span class="s2">&quot;Point&quot;</span><span class="p">:</span>
            <span class="n">center_shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">target_resolution</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_info</span><span class="o">.</span><span class="n">pixres_x</span><span class="p">))</span> <span class="o">*</span> <span class="mf">0.5</span>
            <span class="n">ulx_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_info</span><span class="o">.</span><span class="n">ulx</span> <span class="o">+</span> <span class="n">center_shift</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_info</span><span class="o">.</span><span class="n">pixres_x</span><span class="p">)</span>
            <span class="n">uly_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_info</span><span class="o">.</span><span class="n">uly</span> <span class="o">+</span> <span class="n">center_shift</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_info</span><span class="o">.</span><span class="n">pixres_y</span><span class="p">)</span>
            <span class="n">geo_info</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;ulx&quot;</span><span class="p">:</span> <span class="n">ulx_new</span><span class="p">,</span> <span class="s2">&quot;uly&quot;</span><span class="p">:</span> <span class="n">uly_new</span><span class="p">})</span>
        <span class="n">new_geo_info</span> <span class="o">=</span> <span class="n">GeoInfo</span><span class="p">(</span><span class="o">**</span><span class="n">geo_info</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;values&quot;</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;geo_info&quot;</span><span class="p">,</span> <span class="n">new_geo_info</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;values&quot;</span><span class="p">:</span> <span class="n">res</span><span class="p">,</span> <span class="s2">&quot;geo_info&quot;</span><span class="p">:</span> <span class="n">new_geo_info</span><span class="p">})</span>
            <span class="k">return</span> <span class="n">Band</span><span class="p">(</span><span class="o">**</span><span class="n">attrs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Band.reproject"><a class="viewcode-back" href="../../../packages/eodal.core.band.html#eodal.core.band.Band.reproject">[docs]</a>    <span class="k">def</span> <span class="nf">reproject</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target_crs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">CRS</span><span class="p">],</span>
        <span class="n">interpolation_method</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">Resampling</span><span class="o">.</span><span class="n">nearest</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Projects the raster data into a different spatial coordinate system</span>

<span class="sd">        :param target_crs:</span>
<span class="sd">            EPSG code of the target spatial coordinate system the raster data</span>
<span class="sd">            should be projected to</span>
<span class="sd">        :param dst_transfrom:</span>
<span class="sd">            optional ``Affine`` transformation of the raster data in the target</span>
<span class="sd">            spatial coordinate system</span>
<span class="sd">        :param interpolation_method:</span>
<span class="sd">            interpolation method to use for interpolating grid cells after</span>
<span class="sd">            reprojection. Default is neares neighbor interpolation.</span>
<span class="sd">        :param inplace:</span>
<span class="sd">            if False (default) returns a copy of the ``Band`` instance</span>
<span class="sd">            with the changes applied. If True overwrites the values</span>
<span class="sd">            in the current instance.</span>
<span class="sd">        :param kwargs:</span>
<span class="sd">            optional keyword arguments to pass to ``rasterio.warp.reproject``.</span>
<span class="sd">        :returns:</span>
<span class="sd">            ``Band`` instance if `inplace` is False, None instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># collect options for reprojection</span>
        <span class="n">reprojection_options</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;src_crs&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span>
            <span class="s2">&quot;src_transform&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">,</span>
            <span class="s2">&quot;dst_crs&quot;</span><span class="p">:</span> <span class="n">target_crs</span><span class="p">,</span>
            <span class="s2">&quot;src_nodata&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodata</span><span class="p">,</span>
            <span class="s2">&quot;resampling&quot;</span><span class="p">:</span> <span class="n">interpolation_method</span>
        <span class="p">}</span>
        <span class="n">reprojection_options</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># check for array type; masked arrays are not supported directly</span>
        <span class="c1"># also we have to cast to float for performing the reprojection</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_masked_array</span><span class="p">:</span>
            <span class="n">band_data</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">band_mask</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">fill_value</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ndarray</span><span class="p">:</span>
            <span class="n">band_data</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_zarr</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># set destination array in case dst_transfrom is provided</span>
            <span class="k">if</span> <span class="n">reprojection_options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dst_transfrom&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;destination&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reprojection_options</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;&quot;destination&quot; must be provided &#39;</span> <span class="o">+</span>
                        <span class="s1">&#39;alongside &quot;dst_transform&quot;&#39;</span><span class="p">)</span>

            <span class="n">out_data</span><span class="p">,</span> <span class="n">out_transform</span> <span class="o">=</span> <span class="n">reproject_raster_dataset</span><span class="p">(</span>
                <span class="n">raster</span><span class="o">=</span><span class="n">band_data</span><span class="p">,</span> <span class="o">**</span><span class="n">reprojection_options</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ReprojectionError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not re-project band </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">band_name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># cast array back to original data type</span>
        <span class="c1"># make sure to handle NaNs properly</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">out_data</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">float</span><span class="p">:</span>
            <span class="n">out_data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">out_data</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">out_data</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">out_data</span> <span class="o">=</span> <span class="n">out_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">out_data</span> <span class="o">=</span> <span class="n">out_data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># reproject the mask separately</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_masked_array</span><span class="p">:</span>
            <span class="n">out_mask</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">reproject_raster_dataset</span><span class="p">(</span>
                <span class="n">raster</span><span class="o">=</span><span class="n">band_mask</span><span class="p">,</span> <span class="o">**</span><span class="n">reprojection_options</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">out_mask</span> <span class="o">=</span> <span class="n">out_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">out_mask</span> <span class="o">=</span> <span class="n">out_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
            <span class="c1"># mask also those pixels which were set to nodata after reprojection</span>
            <span class="c1"># due to the raster alignment</span>
            <span class="n">nodata</span> <span class="o">=</span> <span class="n">reprojection_options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;src_nodata&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">out_mask</span><span class="p">[</span><span class="n">out_data</span> <span class="o">==</span> <span class="n">nodata</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">out_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">out_data</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">out_mask</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>

        <span class="n">new_geo_info</span> <span class="o">=</span> <span class="n">GeoInfo</span><span class="o">.</span><span class="n">from_affine</span><span class="p">(</span><span class="n">affine</span><span class="o">=</span><span class="n">out_transform</span><span class="p">,</span> <span class="n">epsg</span><span class="o">=</span><span class="n">target_crs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;values&quot;</span><span class="p">,</span> <span class="n">out_data</span><span class="p">)</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;geo_info&quot;</span><span class="p">,</span> <span class="n">new_geo_info</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;values&quot;</span><span class="p">:</span> <span class="n">out_data</span><span class="p">,</span> <span class="s2">&quot;geo_info&quot;</span><span class="p">:</span> <span class="n">new_geo_info</span><span class="p">})</span>
            <span class="k">return</span> <span class="n">Band</span><span class="p">(</span><span class="o">**</span><span class="n">attrs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Band.reduce"><a class="viewcode-back" href="../../../packages/eodal.core.band.html#eodal.core.band.Band.reduce">[docs]</a>    <span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">List</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Number</span><span class="p">]]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;min&quot;</span><span class="p">,</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;std&quot;</span><span class="p">,</span> <span class="s2">&quot;max&quot;</span><span class="p">,</span> <span class="s2">&quot;count&quot;</span><span class="p">],</span>
        <span class="n">by</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Path</span> <span class="o">|</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span> <span class="o">|</span> <span class="n">Polygon</span> <span class="o">|</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">keep_nans</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reduces the raster data to scalar values by calling `rasterstats`.</span>

<span class="sd">        The reduction can be done on the whole band or by using vector features.</span>

<span class="sd">        IMPORTANT:</span>
<span class="sd">            NaNs in the data are handled by `rasterstats` internally. Therefore, passing</span>
<span class="sd">            numpy nan-functions (e.g., `nanmedian`) is **NOT** necessary and users are</span>
<span class="sd">            **discouraged** from doing so as passing `nanmedian` will ignore existing</span>
<span class="sd">            masks.</span>

<span class="sd">        :param method:</span>
<span class="sd">            list of `numpy` function names and/ or custom function prototypes to use</span>
<span class="sd">            for reducing raster data. Please see also the official `rasterstats` docs</span>
<span class="sd">            /https://pythonhosted.org/rasterstats/manual.html#user-defined-statistics)</span>
<span class="sd">            about how to pass custom functions.</span>
<span class="sd">        :param by:</span>
<span class="sd">            define optional vector features by which to reduce the band. By passing</span>
<span class="sd">            `&#39;self&#39;` the method uses the features with which the band was read,</span>
<span class="sd">            otherwise specify a file-path to vector features or provide a</span>
<span class="sd">            GeoDataFrame.</span>
<span class="sd">        :param keep_nans:</span>
<span class="sd">            .. versionadded:: 0.2.0</span>
<span class="sd">            whether to keep or discard results that were `nan`. This could happen</span>
<span class="sd">            if a feature does not overlap the raster.</span>
<span class="sd">        :returns:</span>
<span class="sd">            list of dictionaries with scalar results per feature including</span>
<span class="sd">            their geometry and further attributes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check by what features the Band should be reduced spatially</span>
        <span class="c1"># if `by` is None use the full spatial extent of the band</span>
        <span class="k">if</span> <span class="n">by</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">features</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">geometry</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">],</span> <span class="n">crs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">by</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">by</span> <span class="o">==</span> <span class="s2">&quot;self&quot;</span><span class="p">:</span>
                    <span class="n">features</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vector_features</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;When passing a string you must pass `self`&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">by</span><span class="p">,</span> <span class="n">Path</span><span class="p">):</span>
                <span class="n">features</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">by</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">by</span><span class="p">,</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">):</span>
                <span class="n">features</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">by</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">by</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">by</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">):</span>
                <span class="n">features</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">geometry</span><span class="o">=</span><span class="p">[</span><span class="n">by</span><span class="p">],</span> <span class="n">crs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s1">&#39;by expected &quot;self&quot;, Path, (Multi)Polygon and GeoDataFrame &#39;</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;objects - got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">by</span><span class="p">)</span><span class="si">}</span><span class="s2"> instead&quot;</span>
                <span class="p">)</span>
        <span class="c1"># check if features has the same CRS as the band. Reproject features if required</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">features</span><span class="o">.</span><span class="n">crs</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">:</span>
            <span class="n">features</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">crs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># check method string passed</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">method</span> <span class="o">=</span> <span class="p">[</span><span class="n">method</span><span class="p">]</span>

        <span class="c1"># compute statistics by calling rasterstats. rasterstats needs the</span>
        <span class="c1"># Affine transformation matrix to work on numpy arrays</span>
        <span class="n">affine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_info</span><span class="o">.</span><span class="n">as_affine</span><span class="p">()</span>
        <span class="c1"># check the passed functions. Depending on the type passed rasterstats</span>
        <span class="c1"># has to be called slightly differently</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span>  <span class="c1"># set the default to count to bypass rasterstats defaults</span>
        <span class="n">add_stats</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">stats_operator_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># loop over operators in method list and make them rasterstats compatible</span>
        <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">method</span><span class="p">:</span>
            <span class="c1"># check if operator passed is a string</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="c1"># the usage of nan-functions is discouraged</span>
                <span class="k">if</span> <span class="n">operator</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;The usage of numpy-nan functions is discouraged and therefore &quot;</span>
                        <span class="s2">&quot;raises an error.&quot;</span>
                        <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">The handling of NaNs is done by `rasterstats` internally and&quot;</span>
                        <span class="s2">&quot; therefore does not&quot;</span>
                        <span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> need to be specified. Please pass operators by their &quot;</span>
                        <span class="s2">&quot;standard numpy names (e.g., &#39;mean&#39;)&quot;</span>
                    <span class="p">)</span>
                <span class="c1"># check if the operator is a standard rasterstats operator</span>
                <span class="c1"># raises a ValueError if the passed operator is not implemented</span>
                <span class="n">check_stats</span><span class="p">(</span><span class="n">stats</span><span class="o">=</span><span class="p">[</span><span class="n">operator</span><span class="p">],</span> <span class="n">categorical</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">stats</span> <span class="o">=</span> <span class="p">[</span><span class="n">operator</span><span class="p">]</span>
            <span class="c1"># the passed operator can be also a function prototype (callable)</span>
            <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">operator</span><span class="p">):</span>
                <span class="n">add_stats</span> <span class="o">=</span> <span class="p">{</span><span class="n">operator</span><span class="o">.</span><span class="vm">__name__</span><span class="p">:</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">operator</span><span class="p">)}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Could not pass </span><span class="si">{</span><span class="n">operator</span><span class="si">}</span><span class="s2"> to rasterstats.</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;Please check the rasterstats docs how to &quot;</span>
                    <span class="s2">&quot;pass user-defined statistics:</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;https://pythonhosted.org/rasterstats/manual.html#user-defined-statistics&quot;</span>   <span class="c1"># noqa: E501</span>
                <span class="p">)</span>

            <span class="c1"># get raster values from EOdal band</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># check if data is masked array</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_masked_array</span><span class="p">:</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

            <span class="c1"># check no-data value. Rasterstats fails when nodata is nan</span>
            <span class="c1"># and the dtype of vals is int</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">vals</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodata</span><span class="p">):</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

            <span class="c1"># call rasterstats.zonal_stats for the current operator</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">zonal_stats</span><span class="p">(</span>
                <span class="n">features</span><span class="p">,</span>
                <span class="n">vals</span><span class="p">,</span>
                <span class="n">affine</span><span class="o">=</span><span class="n">affine</span><span class="p">,</span>
                <span class="n">stats</span><span class="o">=</span><span class="n">stats</span><span class="p">,</span>
                <span class="n">add_stats</span><span class="o">=</span><span class="n">add_stats</span><span class="p">,</span>
                <span class="n">nodata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nodata</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">stats_operator_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

        <span class="c1"># combine the list of stats into a format consistent with the standard</span>
        <span class="c1"># zonal_stats call</span>
        <span class="n">_stats</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">features</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">feature_stats</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">odx</span><span class="p">,</span> <span class="n">operator</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
                <span class="n">_operator</span> <span class="o">=</span> <span class="n">operator</span>
                <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">_operator</span><span class="p">):</span>
                    <span class="n">_operator</span> <span class="o">=</span> <span class="n">_operator</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="n">feature_operator_res</span> <span class="o">=</span> <span class="n">stats_operator_list</span><span class="p">[</span><span class="n">odx</span><span class="p">][</span><span class="n">idx</span><span class="p">][</span><span class="n">_operator</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_nans</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">feature_operator_res</span><span class="p">):</span>
                            <span class="k">continue</span>
                    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                        <span class="c1"># rasterstats returns None instead of nan</span>
                        <span class="k">if</span> <span class="n">feature_operator_res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">continue</span>
                <span class="n">feature_stats</span><span class="p">[</span><span class="n">_operator</span><span class="p">]</span> <span class="o">=</span> <span class="n">feature_operator_res</span>
            <span class="c1"># do not add features without statistics</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">feature_stats</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># save the geometries and all other attributes of the feature(s) used</span>
            <span class="n">feature_stats</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">features</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>
            <span class="n">feature_stats</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;crs&quot;</span><span class="p">:</span> <span class="n">features</span><span class="o">.</span><span class="n">crs</span><span class="p">})</span>
            <span class="n">_stats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feature_stats</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_stats</span></div>

<div class="viewcode-block" id="Band.scale_data"><a class="viewcode-back" href="../../../packages/eodal.core.band.html#eodal.core.band.Band.scale_data">[docs]</a>    <span class="k">def</span> <span class="nf">scale_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">pixel_values_to_ignore</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[],</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies scale and offset factors to the data.</span>

<span class="sd">        .. versionadded:: 0.2.3</span>
<span class="sd">            No-data values are ignored when applying scale and offset.</span>

<span class="sd">        :param inplace:</span>
<span class="sd">            if False (default) returns a copy of the ``Band`` instance</span>
<span class="sd">            with the changes applied. If True overwrites the values</span>
<span class="sd">            in the current instance.</span>
<span class="sd">        :param pixel_values_to_ignore:</span>
<span class="sd">            optional list of pixel values to ignore, i.e., where scaling</span>
<span class="sd">            has no effect. From version 0.2.3 onwards, no-data values</span>
<span class="sd">            are *always* ignored.</span>
<span class="sd">        :returns:</span>
<span class="sd">            ``Band`` instance if `inplace` is False, None instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># add no-data to the `pixel_values_to_ignore` list</span>
        <span class="n">pixel_values_to_ignore</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodata</span><span class="p">)</span>

        <span class="n">scale</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_masked_array</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pixel_values_to_ignore</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">scaled_array</span> <span class="o">=</span> <span class="n">scale</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">data</span> <span class="o">-</span> <span class="n">offset</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">scaled_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
                <span class="n">scaled_array</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">scaled_array</span><span class="p">,</span> <span class="n">pixel_values_to_ignore</span><span class="p">)]</span> <span class="o">=</span> <span class="n">scale</span> <span class="o">*</span> \
                    <span class="n">scaled_array</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">scaled_array</span><span class="p">,</span> <span class="n">pixel_values_to_ignore</span><span class="p">)]</span> \
                    <span class="o">-</span> <span class="n">offset</span>
            <span class="c1"># reuse fill value</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">fill_value</span>
            <span class="n">scaled_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">scaled_array</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ndarray</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pixel_values_to_ignore</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">scaled_array</span> <span class="o">=</span> <span class="n">scale</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="n">offset</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">scaled_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
                <span class="n">scaled_array</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">scaled_array</span><span class="p">,</span> <span class="n">pixel_values_to_ignore</span><span class="p">)]</span> <span class="o">=</span> <span class="n">scale</span> <span class="o">*</span> \
                    <span class="n">scaled_array</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">scaled_array</span><span class="p">,</span> <span class="n">pixel_values_to_ignore</span><span class="p">)]</span> \
                    <span class="o">-</span> <span class="n">offset</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_zarr</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;values&quot;</span><span class="p">,</span> <span class="n">scaled_array</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;values&quot;</span><span class="p">:</span> <span class="n">scaled_array</span><span class="p">})</span>
            <span class="k">return</span> <span class="n">Band</span><span class="p">(</span><span class="o">**</span><span class="n">attrs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Band.to_dataframe"><a class="viewcode-back" href="../../../packages/eodal.core.band.html#eodal.core.band.Band.to_dataframe">[docs]</a>    <span class="k">def</span> <span class="nf">to_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a ``GeoDataFrame`` from the raster band data</span>

<span class="sd">        :returns:</span>
<span class="sd">            ``GeoDataFrame`` of raster values in the spatial coordinate</span>
<span class="sd">            system of the raster band data. The geometry type is always</span>
<span class="sd">            ``Point``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get coordinates of the first band in flattened format</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flatten_coordinates</span><span class="p">()</span>
        <span class="c1"># get EPSG code</span>
        <span class="n">epsg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_info</span><span class="o">.</span><span class="n">epsg</span>

        <span class="c1"># if the band is a masked array, we need numpy.ma functions</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrows</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncols</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_masked_array</span><span class="p">:</span>
            <span class="n">flattened</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>
            <span class="c1"># save mask to array</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">flattened</span><span class="o">.</span><span class="n">mask</span>
            <span class="c1"># compress array (removes masked values)</span>
            <span class="n">flattened</span> <span class="o">=</span> <span class="n">flattened</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>
            <span class="c1"># mask band coordinates</span>
            <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">:</span>
                <span class="n">coord_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">coords</span><span class="p">[</span><span class="n">coord</span><span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
                <span class="n">coord_compressed</span> <span class="o">=</span> <span class="n">coord_masked</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>
                <span class="n">coords</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">coord</span><span class="p">:</span> <span class="n">coord_compressed</span><span class="p">})</span>
        <span class="c1"># otherwise we can use numpy ndarray&#39;s functions</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ndarray</span><span class="p">:</span>
            <span class="n">flattened</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_zarr</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

        <span class="c1"># convert the coordinates to shapely geometries</span>
        <span class="n">coordinate_geoms</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">Point</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]))</span>
        <span class="p">]</span>
        <span class="c1"># call the GeoDataFrame constructor</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">geometry</span><span class="o">=</span><span class="n">coordinate_geoms</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">epsg</span><span class="p">)</span>
        <span class="c1"># add band data</span>
        <span class="n">gdf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">band_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">flattened</span>

        <span class="k">return</span> <span class="n">gdf</span></div>

<div class="viewcode-block" id="Band.to_xarray"><a class="viewcode-back" href="../../../packages/eodal.core.band.html#eodal.core.band.Band.to_xarray">[docs]</a>    <span class="k">def</span> <span class="nf">to_xarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attributes</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a ``xarray.Dataset`` from the raster band data</span>
<span class="sd">        (dime</span>

<span class="sd">        NOTE:</span>
<span class="sd">            To ensure consistency with ``xarray`` pixel coordinates are</span>
<span class="sd">            shifted from the upper left pixel corner to the center.</span>

<span class="sd">        :param attributes:</span>
<span class="sd">            additional raster attributes to update or add</span>
<span class="sd">        :param kwargs:</span>
<span class="sd">            additional key-word arguments to pass to `~xarray.Dataset`</span>
<span class="sd">        :return:</span>
<span class="sd">            ``xarray.DataArray`` with x and y coordinates. Raster attributes</span>
<span class="sd">            are preserved.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">band_data</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="c1"># masked pixels are set to nodata</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_masked_array</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">band_data</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodata</span><span class="p">)</span>
            <span class="c1"># on type error cast to float since this is most likely caused</span>
            <span class="c1"># by a data type miss-match (int &lt;-&gt; float)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">band_data</span> <span class="o">=</span> <span class="n">band_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
                <span class="n">band_data</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodata</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot set masked pixels to nodata: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># get coordinates and shift them half a pixel size if the current</span>
        <span class="c1"># pixel coordinate model is Area (GDAL default) since xarray follows</span>
        <span class="c1"># the convention for NETCDF and expects Point coordinates</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span>
        <span class="n">coords</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;band&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">band_name</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)})</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">area_or_point</span> <span class="o">==</span> <span class="s2">&quot;Area&quot;</span><span class="p">:</span>
            <span class="n">shift_x</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_info</span><span class="o">.</span><span class="n">pixres_x</span>
            <span class="n">shift_y</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_info</span><span class="o">.</span><span class="n">pixres_y</span>
            <span class="n">coords</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">val</span> <span class="o">+</span> <span class="n">shift_x</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]],</span>
                    <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">val</span> <span class="o">+</span> <span class="n">shift_y</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]],</span>
                <span class="p">}</span>
            <span class="p">)</span>

        <span class="c1"># define attributes</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attributes</span><span class="p">(</span><span class="o">**</span><span class="n">attributes</span><span class="p">)</span>

        <span class="c1"># call DataArray constructor</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">band_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">band_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">xarr</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">band_data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_shape</span><span class="p">),</span>
            <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;band&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">),</span>
            <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span>
            <span class="n">attrs</span><span class="o">=</span><span class="n">attrs</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">xarr</span></div>

<div class="viewcode-block" id="Band.to_rasterio"><a class="viewcode-back" href="../../../packages/eodal.core.band.html#eodal.core.band.Band.to_rasterio">[docs]</a>    <span class="k">def</span> <span class="nf">to_rasterio</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fpath_raster</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes the band data to a raster dataset using ``rasterio``.</span>

<span class="sd">        :param fpath_raster:</span>
<span class="sd">            file-path to the raster dataset to create. The ``rasterio``</span>
<span class="sd">            driver is identified by the file-name extension. In case</span>
<span class="sd">            jp2 is selected, loss-less compression is carried out.</span>
<span class="sd">        :param kwargs:</span>
<span class="sd">            additional keyword arguments to append to metadata dictionary</span>
<span class="sd">            used by ``rasterio`` to write datasets</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check output file naming and driver</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">driver</span> <span class="o">=</span> <span class="n">driver_from_extension</span><span class="p">(</span><span class="n">fpath_raster</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Could not determine GDAL driver for &quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">fpath_raster</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># construct meta dictionary required by rasterio</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_meta</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># make sure JPEG compression is loss-less</span>
        <span class="k">if</span> <span class="n">driver</span> <span class="o">==</span> <span class="s2">&quot;JP2OpenJPEG&quot;</span><span class="p">:</span>
            <span class="n">meta</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;QUALITY&quot;</span><span class="p">:</span> <span class="s2">&quot;100&quot;</span><span class="p">,</span> <span class="s2">&quot;REVERSIBLE&quot;</span><span class="p">:</span> <span class="s2">&quot;YES&quot;</span><span class="p">})</span>

        <span class="c1"># open the result dataset and try to write the bands</span>
        <span class="k">with</span> <span class="n">rio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fpath_raster</span><span class="p">,</span> <span class="s2">&quot;w+&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">meta</span><span class="p">)</span> <span class="k">as</span> <span class="n">dst</span><span class="p">:</span>
            <span class="c1"># set band name</span>
            <span class="n">dst</span><span class="o">.</span><span class="n">set_band_description</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_name</span><span class="p">)</span>
            <span class="c1"># set scale and offset</span>
            <span class="n">dst</span><span class="o">.</span><span class="n">_set_all_scales</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">])</span>
            <span class="n">dst</span><span class="o">.</span><span class="n">_set_all_offsets</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">])</span>
            <span class="c1"># write band data</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_masked_array</span><span class="p">:</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">data</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">mask</span>
                <span class="n">vals</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodata</span>
                <span class="n">dst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ndarray</span><span class="p">:</span>
                <span class="n">dst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span></div></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">eodal</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Table of Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../packages/modules.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source/changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../py-modindex.html">Module Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../genindex.html">Index</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, Crop Science, Institute of Agricultural Sciences, D-USYS, ETH Zurich, Zurich, Switzerland;
Earth Observation of Agroecosystems Team, Division Agroecology and Environment, Agroscope, Zurich, Switzerland.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>