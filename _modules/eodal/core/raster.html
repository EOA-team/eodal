
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>eodal.core.raster &#8212; eodal 0.2.2 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for eodal.core.raster</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module defines the ``RasterCollection`` class which is the basic class for reading,</span>
<span class="sd">plotting, transforming, manipulating and writing (geo-referenced) raster data in an</span>
<span class="sd">intuitive, object-oriented way (in terms of software philosophy).</span>

<span class="sd">A ``RasterCollection`` is collection of to zero to N `~eodal.core.band.Band` instances,</span>
<span class="sd">in which each band denotes a two-dimensional array at its core. The ``RasterCollection``</span>
<span class="sd">class allows thereby to handle ``Band`` instances with different spatial reference</span>
<span class="sd">systems, spatial resolutions (i.e., grid cell sizes) and spatial extents.</span>

<span class="sd">Besides that, ``RasterCollection`` is a super class from which sensor-specific classes</span>
<span class="sd">for reading (satellite) raster image data inherit.</span>

<span class="sd">.. highlight:: python</span>
<span class="sd">.. code-block:: python</span>

<span class="sd">    import numpy as np</span>
<span class="sd">    from eodal.core.raster import RasterCollection</span>
<span class="sd">    from eodal.core.band import Band</span>
<span class="sd">    from eodal.core.band import GeoInfo</span>

<span class="sd">    # New collection from `numpy.ndarray`</span>
<span class="sd">    # Define GeoInfo and Array first and use them to initialize a new RasterCollection</span>
<span class="sd">    # instance:</span>

<span class="sd">    # provide EPSG code</span>
<span class="sd">    epsg = 32633</span>
<span class="sd">    # provide upper left (ul) x and y coordinate (in units of the coordinate system</span>
<span class="sd">    # given by the EPSG code defined above)</span>
<span class="sd">    ulx, uly = 300000, 5100000</span>
<span class="sd">    # provide pixel size (spatial resolution). Note that resolution in y direction is</span>
<span class="sd">    # negative because we start at the upper left corner</span>
<span class="sd">    pixres_x, pixres_y = 10, -10</span>

<span class="sd">    # get a new GeoInfo object</span>
<span class="sd">    geo_info = GeoInfo(epsg=epsg,ulx=ulx,uly=uly,pixres_x=pixres_x,pixres_y=pixres_y)</span>

<span class="sd">    # define a band name for the band data to add</span>
<span class="sd">    band_name = &#39;random&#39;</span>
<span class="sd">    # optionally, you can also asign a `band_alias` (e.g., color name)</span>
<span class="sd">    band_alias = &#39;blue&#39;</span>

<span class="sd">    # let&#39;s define some random numbers in a 2-d array</span>
<span class="sd">    values = np.random.random(size=(100,120))</span>

<span class="sd">    # get the RasterCollection object</span>
<span class="sd">    raster = RasterCollection(</span>
<span class="sd">             band_constructor=Band,</span>
<span class="sd">             band_name=band_name,</span>
<span class="sd">             values=values,</span>
<span class="sd">             band_alias=band_alias,</span>
<span class="sd">             geo_info=geo_info</span>
<span class="sd">    )</span>

<span class="sd">Copyright (C) 2022 Lukas Valentin Graf</span>

<span class="sd">This program is free software: you can redistribute it and/or modify</span>
<span class="sd">it under the terms of the GNU General Public License as published by</span>
<span class="sd">the Free Software Foundation, either version 3 of the License, or</span>
<span class="sd">(at your option) any later version.</span>

<span class="sd">This program is distributed in the hope that it will be useful,</span>
<span class="sd">but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="sd">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="sd">GNU General Public License for more details.</span>

<span class="sd">You should have received a copy of the GNU General Public License</span>
<span class="sd">along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.ticker</span> <span class="k">as</span> <span class="nn">ticker</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">rasterio</span> <span class="k">as</span> <span class="nn">rio</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>
<span class="kn">import</span> <span class="nn">zarr</span>

<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">MutableMapping</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">colors</span>
<span class="kn">from</span> <span class="nn">matplotlib.axes</span> <span class="kn">import</span> <span class="n">Axes</span>
<span class="kn">from</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">import</span> <span class="n">Figure</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">rasterio.drivers</span> <span class="kn">import</span> <span class="n">driver_from_extension</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span>

<span class="kn">from</span> <span class="nn">eodal.config</span> <span class="kn">import</span> <span class="n">get_settings</span>
<span class="kn">from</span> <span class="nn">eodal.core.band</span> <span class="kn">import</span> <span class="n">Band</span>
<span class="kn">from</span> <span class="nn">eodal.core.operators</span> <span class="kn">import</span> <span class="n">Operator</span>
<span class="kn">from</span> <span class="nn">eodal.core.spectral_indices</span> <span class="kn">import</span> <span class="n">SpectralIndices</span>
<span class="kn">from</span> <span class="nn">eodal.utils.constants</span> <span class="kn">import</span> <span class="n">ProcessingLevels</span>
<span class="kn">from</span> <span class="nn">eodal.utils.decorators</span> <span class="kn">import</span> <span class="n">check_band_names</span>
<span class="kn">from</span> <span class="nn">eodal.utils.exceptions</span> <span class="kn">import</span> <span class="n">BandNotFoundError</span>

<span class="n">Settings</span> <span class="o">=</span> <span class="n">get_settings</span><span class="p">()</span>


<div class="viewcode-block" id="SceneProperties"><a class="viewcode-back" href="../../../packages/eodal.core.raster.html#eodal.core.raster.SceneProperties">[docs]</a><span class="k">class</span> <span class="nc">SceneProperties</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for storing scene-relevant properties</span>

<span class="sd">    :attribute acquisition_time:</span>
<span class="sd">        image acquisition time</span>
<span class="sd">    :attribute platform:</span>
<span class="sd">        name of the imaging platform</span>
<span class="sd">    :attribute sensor:</span>
<span class="sd">        name of the imaging sensor</span>
<span class="sd">    :attribute processing_level:</span>
<span class="sd">        processing level of the remotely sensed data (if</span>
<span class="sd">        known and applicable)</span>
<span class="sd">    :attribute product_uri:</span>
<span class="sd">        unique product (scene) identifier</span>
<span class="sd">    :attribute mode:</span>
<span class="sd">        imaging mode of SAR sensors</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SceneProperties.__init__"><a class="viewcode-back" href="../../../packages/eodal.core.raster.html#eodal.core.raster.SceneProperties.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">acquisition_time</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span> <span class="o">|</span> <span class="n">Number</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">platform</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">sensor</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">processing_level</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ProcessingLevels</span><span class="p">]</span> <span class="o">=</span> <span class="n">ProcessingLevels</span><span class="o">.</span><span class="n">UNKNOWN</span><span class="p">,</span>
        <span class="n">product_uri</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Class constructor</span>

<span class="sd">        :param acquisition_time:</span>
<span class="sd">            image acquisition time. Can be a timestamp or any kind of numeric</span>
<span class="sd">            index.</span>
<span class="sd">        :param platform:</span>
<span class="sd">            name of the imaging platform</span>
<span class="sd">        :param sensor:</span>
<span class="sd">            name of the imaging sensor</span>
<span class="sd">        :param processing_level:</span>
<span class="sd">            processing level of the remotely sensed data (if</span>
<span class="sd">            known and applicable)</span>
<span class="sd">        :param product_uri:</span>
<span class="sd">            unique product (scene) identifier</span>
<span class="sd">        :attribute mode:</span>
<span class="sd">            imaging mode of SAR sensors</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">acquisition_time</span> <span class="o">=</span> <span class="n">acquisition_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">platform</span> <span class="o">=</span> <span class="n">platform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sensor</span> <span class="o">=</span> <span class="n">sensor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processing_level</span> <span class="o">=</span> <span class="n">processing_level</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">product_uri</span> <span class="o">=</span> <span class="n">product_uri</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">acquisition_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;acquisition time of the scene&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_acquisition_time</span>

    <span class="nd">@acquisition_time</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">acquisition_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">:</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;acquisition time of the scene&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">Number</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expected a datetime.datetime or Number object&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_acquisition_time</span> <span class="o">=</span> <span class="n">time</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">platform</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;name of the imaging platform&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_platform</span>

    <span class="nd">@platform</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">platform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;name of the imaging plaform&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expected a str object&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_platform</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sensor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;name of the sensor&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sensor</span>

    <span class="nd">@sensor</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">sensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;name of the sensor&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expected a str object&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sensor</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">processing_level</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ProcessingLevels</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;current processing level&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_processing_level</span>

    <span class="nd">@processing_level</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">processing_level</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">ProcessingLevels</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_processing_level</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">product_uri</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;unique product (scene) identifier&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_product_uri</span>

    <span class="nd">@product_uri</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">product_uri</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;unique product (scene) identifier&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expected a str object&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_product_uri</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mode</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;imaging mode of SAR sensors&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span>

    <span class="nd">@mode</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expected a str object&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">=</span> <span class="n">value</span>

<div class="viewcode-block" id="SceneProperties.are_populated"><a class="viewcode-back" href="../../../packages/eodal.core.raster.html#eodal.core.raster.SceneProperties.are_populated">[docs]</a>    <span class="k">def</span> <span class="nf">are_populated</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns a Boolean flag indicating if the class attributes</span>
<span class="sd">        have been populated with actual data or still equal defaults.</span>

<span class="sd">        A scene must have at least a time stamp.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;acquisition_time&quot;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RasterOperator"><a class="viewcode-back" href="../../../packages/eodal.core.raster.html#eodal.core.raster.RasterOperator">[docs]</a><span class="k">class</span> <span class="nc">RasterOperator</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Band operator supporting basic algebraic operations on</span>
<span class="sd">    `RasterCollection` objects</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RasterOperator.calc"><a class="viewcode-back" href="../../../packages/eodal.core.raster.html#eodal.core.raster.RasterOperator.calc">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">calc</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">a</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">Band</span> <span class="o">|</span> <span class="n">Number</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">operator</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">band_selection</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">right_sided</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        executes a custom algebraic operator on `RasterCollection` objects</span>

<span class="sd">        :param a:</span>
<span class="sd">            `RasterCollection` object with values (non-empty)</span>
<span class="sd">        :param other:</span>
<span class="sd">            `Band` object, scalar, 3-dimensional `numpy.array`, or RasterCollection to</span>
<span class="sd">            use on the right-hand side of the operator. If a `numpy.array` is passed</span>
<span class="sd">            the array must have either shape `(1,nrows,ncols)` or `(nband,nrows,ncols)`</span>
<span class="sd">            where `nrows` is the number of rows in `a`, ncols the number of columns</span>
<span class="sd">            in `a` and `nbands` the number of bands in a or the selection thereof.</span>
<span class="sd">            The latter method does *not* work if the bands in `a` selected differ</span>
<span class="sd">            in their shape.</span>
<span class="sd">        :param operator:</span>
<span class="sd">            symbolic representation of the operator (e.g., &#39;+&#39;</span>
<span class="sd">            for addition)</span>
<span class="sd">        :param inplace:</span>
<span class="sd">            returns a new `RasterCollection` object if False (default) otherwise</span>
<span class="sd">            overwrites the current `RasterCollection` data in `a`</span>
<span class="sd">        :param band_selection:</span>
<span class="sd">            optional selection of bands in `a` to which apply the operation</span>
<span class="sd">        :param right_sided:</span>
<span class="sd">            optional flag indicated that the order of `a` and `other` has to be</span>
<span class="sd">            switched. `False` by default. Set to `True` if the order of argument</span>
<span class="sd">            matters, i.e., for right-hand sided expression in case of subtraction,</span>
<span class="sd">            division and power.</span>
<span class="sd">        :returns:</span>
<span class="sd">            `numpy.ndarray` if inplace is False, None instead</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">check_operator</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">operator</span><span class="p">)</span>
        <span class="c1"># make a copy of a to avoid overwriting the original values</span>
        <span class="n">_a</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

        <span class="c1"># if `other` is a Band object get its values</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Band</span><span class="p">):</span>
            <span class="n">_other</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="n">_other</span> <span class="o">=</span> <span class="n">_other</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># check if `other` matches the shape</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
            <span class="c1"># check if passed array is 2-d</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">band_selection</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">::]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Passed array has wrong number of rows and columns. &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Expected </span><span class="si">{</span><span class="n">a</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">::]</span><span class="si">}</span><span class="s2"> - Got </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
            <span class="c1"># or 3-d</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">band_selection</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Passed array has wrong dimensions. Expected </span><span class="si">{</span><span class="n">a</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot; - Got </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
            <span class="c1"># other dimensions are not allowed</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Passed array must 2 or 3-dimensional. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="si">}</span><span class="s2"> dimensions instead&quot;</span>
                <span class="p">)</span>
            <span class="n">_other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">RasterCollection</span><span class="p">):</span>
            <span class="n">_other</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="n">_other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">band_selection</span><span class="o">=</span><span class="n">band_selection</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">_other</span> <span class="o">=</span> <span class="n">other</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2"> is not supported&quot;</span><span class="p">)</span>

        <span class="c1"># perform the operation</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># mind the order which is important for some operators</span>
            <span class="k">if</span> <span class="n">right_sided</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;_other </span><span class="si">{</span><span class="n">operator</span><span class="si">}</span><span class="s2"> _a.get_values(band_selection)&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;_a.get_values(band_selection) </span><span class="si">{</span><span class="n">operator</span><span class="si">}</span><span class="s2"> _other&quot;</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">cls</span><span class="o">.</span><span class="n">BandMathError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not execute </span><span class="si">{</span><span class="n">expr</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># return result or overwrite band data</span>
        <span class="k">if</span> <span class="n">band_selection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">band_selection</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">band_names</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">rcoll_out</span> <span class="o">=</span> <span class="n">RasterCollection</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">band_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">band_selection</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">collection</span><span class="p">[</span><span class="n">band_name</span><span class="p">],</span> <span class="s2">&quot;values&quot;</span><span class="p">,</span> <span class="n">res</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">attrs</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">collection</span><span class="p">[</span><span class="n">band_name</span><span class="p">]</span><span class="o">.</span><span class="vm">__dict__</span>
                <span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;values&quot;</span><span class="p">:</span> <span class="n">res</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]})</span>
                <span class="n">rcoll_out</span><span class="o">.</span><span class="n">add_band</span><span class="p">(</span><span class="n">band_constructor</span><span class="o">=</span><span class="n">Band</span><span class="p">,</span> <span class="o">**</span><span class="n">attrs</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rcoll_out</span></div></div>


<div class="viewcode-block" id="RasterCollection"><a class="viewcode-back" href="../../../packages/eodal.core.raster.html#eodal.core.raster.RasterCollection">[docs]</a><span class="k">class</span> <span class="nc">RasterCollection</span><span class="p">(</span><span class="n">MutableMapping</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Basic class for storing and handling single and multi-band raster</span>
<span class="sd">    data from which sensor- or application-specific classes inherit.</span>

<span class="sd">    A ``RasterDataHandler`` contains zero to N instances of</span>
<span class="sd">    `~eodal.core.Band`. Bands are always indexed using their band</span>
<span class="sd">    name, therefore the band name must be **unique**!</span>

<span class="sd">    :attrib scene_properties:</span>
<span class="sd">        instance of `SceneProperties` for storing scene (i.e., dataset-wide)</span>
<span class="sd">        metadata. Designed for the usage with remote sensing data.</span>
<span class="sd">    :attrib band_names:</span>
<span class="sd">        names of the bands currently loaded into the collection</span>
<span class="sd">    :attrib band_aliases:</span>
<span class="sd">        optional aliases of the band names. Thus, a band can be accessed either</span>
<span class="sd">        by its name or its alias.</span>
<span class="sd">    :attrib empty:</span>
<span class="sd">        True if no bands are loaded into the collection, False if bands</span>
<span class="sd">        are available</span>
<span class="sd">    :attrib has_band_aliases:</span>
<span class="sd">        True if the band aliases are provided, False otherwise</span>
<span class="sd">    :attrib collection:</span>
<span class="sd">        dictionary-like collection of loaded raster ``Band`` instances</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RasterCollection.__init__"><a class="viewcode-back" href="../../../packages/eodal.core.raster.html#eodal.core.raster.RasterCollection.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">band_constructor</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Band</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scene_properties</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SceneProperties</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes a new `RasterCollection` with 0 up to n bands</span>

<span class="sd">        :param band_constructor:</span>
<span class="sd">            optional callable returning an `~eodal.core.Band`</span>
<span class="sd">            instance.</span>
<span class="sd">        :param scene_properties:</span>
<span class="sd">            optional scene properties of the dataset handled by the</span>
<span class="sd">            current ``RasterCollection`` instance</span>
<span class="sd">        :param args:</span>
<span class="sd">            arguments to pass to `band_constructor` or one of its</span>
<span class="sd">            class methods (`Band.from_rasterio`, `Band.from_vector`)</span>
<span class="sd">        :param kwargs:</span>
<span class="sd">            key-word arguments to pass to `band_constructor`  or one of its</span>
<span class="sd">            class methods (`Band.from_rasterio`, `Band.from_vector`)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">scene_properties</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scene_properties</span> <span class="o">=</span> <span class="n">SceneProperties</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scene_properties</span><span class="p">,</span> <span class="n">SceneProperties</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;scene_properties takes only objects &quot;</span> <span class="s2">&quot;of type SceneProperties&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scene_properties</span> <span class="o">=</span> <span class="n">scene_properties</span>

        <span class="c1"># bands are stored in a dictionary like collection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_frozen</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collection</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_frozen</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_band_aliases</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">band_constructor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">band</span> <span class="o">=</span> <span class="n">band_constructor</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">band</span><span class="p">,</span> <span class="n">Band</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only Band objects can be passed&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_band_aliases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">band</span><span class="o">.</span><span class="n">band_alias</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">band</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">slice</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Band</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">_get_band_from_key</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Band</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            helper function returning a Band object identified</span>
<span class="sd">            by its name from a RasterCollection</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_names</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_aliases</span><span class="p">:</span>
                    <span class="n">band_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_aliases</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_names</span><span class="p">[</span><span class="n">band_idx</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="c1"># has a single key or slice been passed?</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_get_band_from_key</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">BandNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not find band </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="c1"># find the index of the start and the end of the slice</span>
            <span class="n">slice_start</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">start</span>
            <span class="n">slice_end</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span>
            <span class="c1"># return an empty RasterCollection if start and stop is the same</span>
            <span class="c1"># (numpy array behavior)</span>
            <span class="k">if</span> <span class="n">slice_start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">slice_end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">RasterCollection</span><span class="p">()</span>
            <span class="c1"># if start is None use the first band name or its alias</span>
            <span class="k">if</span> <span class="n">slice_start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">slice_end</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_names</span><span class="p">:</span>
                    <span class="n">slice_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">slice_end</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_aliases</span><span class="p">:</span>
                    <span class="n">slice_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_aliases</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># if end is None use the last band name or its alias</span>
            <span class="n">end_increment</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">slice_end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">slice_start</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_names</span><span class="p">:</span>
                    <span class="n">slice_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_names</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">slice_start</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_aliases</span><span class="p">:</span>
                    <span class="n">slice_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_aliases</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># to ensure that the :: operator works, we need to make</span>
                <span class="c1"># sure the last band is also included in the slice</span>
                <span class="n">end_increment</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="nb">set</span><span class="p">([</span><span class="n">slice_start</span><span class="p">,</span> <span class="n">slice_end</span><span class="p">])</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">band_names</span><span class="p">)):</span>
                <span class="n">idx_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">slice_start</span><span class="p">)</span>
                <span class="n">idx_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">slice_end</span><span class="p">)</span> <span class="o">+</span> <span class="n">end_increment</span>
                <span class="n">bands</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_names</span>
            <span class="k">elif</span> <span class="nb">set</span><span class="p">([</span><span class="n">slice_start</span><span class="p">,</span> <span class="n">slice_end</span><span class="p">])</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">band_aliases</span><span class="p">)):</span>
                <span class="n">idx_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_aliases</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">slice_start</span><span class="p">)</span>
                <span class="n">idx_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_aliases</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">slice_end</span><span class="p">)</span> <span class="o">+</span> <span class="n">end_increment</span>
                <span class="n">bands</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_aliases</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">BandNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not find bands in </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">slice_step</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span>
            <span class="k">if</span> <span class="n">slice_step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">slice_step</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="c1"># get an empty RasterCollection for returing the slide</span>
            <span class="n">out_raster</span> <span class="o">=</span> <span class="n">RasterCollection</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">idx_start</span><span class="p">,</span> <span class="n">idx_end</span><span class="p">,</span> <span class="n">slice_step</span><span class="p">):</span>
                <span class="n">out_raster</span><span class="o">.</span><span class="n">add_band</span><span class="p">(</span><span class="n">_get_band_from_key</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">bands</span><span class="p">[</span><span class="n">idx</span><span class="p">]))</span>
            <span class="k">return</span> <span class="n">out_raster</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="n">Band</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">Band</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only Band objects can be passed&quot;</span><span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">band_name</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Duplicate band names are not permitted&quot;</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collection</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">collection</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">RasterOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;+&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">RasterOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;+&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">RasterOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">RasterOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="n">right_sided</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">RasterOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;**&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rpow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">RasterOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;**&quot;</span><span class="p">,</span> <span class="n">right_sided</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">RasterOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;&lt;=&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rle__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">RasterOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;&lt;=&quot;</span><span class="p">,</span> <span class="n">right_sided</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">RasterOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;&gt;=&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">RasterOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;&gt;=&quot;</span><span class="p">,</span> <span class="n">right_sided</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">RasterOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">RasterOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="n">right_sided</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">RasterOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">RasterOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">RasterOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;!=&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">RasterOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;!=&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">RasterOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;==&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__req__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">RasterOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;==&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">RasterOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;&gt;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rgt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">RasterOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;&gt;&quot;</span><span class="p">,</span> <span class="n">right_sided</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">RasterOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;&lt;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rlt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">RasterOperator</span><span class="o">.</span><span class="n">calc</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="n">right_sided</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;Empty EOdal RasterCollection&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="s2">&quot;EOdal RasterCollection</span><span class="se">\n</span><span class="s2">----------------------</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s1">&#39;# Bands:    </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s1">Band names:    &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">band_names</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;Band aliases:    </span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">band_aliases</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">band_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;band names in collection&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">band_aliases</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;band aliases in collection&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_band_aliases</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Handler has bands loaded&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">collection</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">collection</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MutableMapping</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;collection of the bands currently loaded&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_collection</span>

    <span class="nd">@collection</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">collection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;collection of the bands currently loaded&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only dictionaries can be passed&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frozen</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Existing collections cannot be overwritten&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frozen</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_collection</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_band_aliases</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;collection supports aliasing&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">band_aliases</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_scene</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;is the RasterCollection a scene&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene_properties</span><span class="o">.</span><span class="n">are_populated</span><span class="p">()</span>

<div class="viewcode-block" id="RasterCollection.get_band_alias"><a class="viewcode-back" href="../../../packages/eodal.core.raster.html#eodal.core.raster.RasterCollection.get_band_alias">[docs]</a>    <span class="nd">@check_band_names</span>
    <span class="k">def</span> <span class="nf">get_band_alias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">band_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retuns the band_name-alias mapper of a given band</span>
<span class="sd">        in collection if the band has an alias, None instead</span>

<span class="sd">        :param band_name:</span>
<span class="sd">            name of the band for which to return the alias or</span>
<span class="sd">            its name if the alias is provided</span>
<span class="sd">        :returns:</span>
<span class="sd">            mapping of band_name:band_alias (band name is always the</span>
<span class="sd">            key and band_alias is the value)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">band_name</span><span class="p">]</span><span class="o">.</span><span class="n">has_alias</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">band_name</span><span class="p">)</span>
            <span class="n">band_alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_aliases</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">band_name</span><span class="p">:</span> <span class="n">band_alias</span><span class="p">}</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_bands_from_selection</span><span class="p">(</span>
        <span class="n">fpath_raster</span><span class="p">:</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">Dict</span><span class="p">,</span>
        <span class="n">band_idxs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">band_names_src</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">band_names_dst</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Selects bands in a multi-band raster dataset based on a custom</span>
<span class="sd">        selection of band indices or band names.</span>

<span class="sd">        .. versionadd:: 0.2.0</span>
<span class="sd">            works also with a dictionary of hrefs returned from a</span>
<span class="sd">            STAC query</span>

<span class="sd">        :param fpath_raster:</span>
<span class="sd">            file-path to the raster file (technically spoken, this</span>
<span class="sd">            can also have just a single band) **or** when `USE_STAC` is True</span>
<span class="sd">            the `assets` dictionary returned from a STAC call.</span>
<span class="sd">        :param band_idxs:</span>
<span class="sd">            optional list of band indices in the raster dataset</span>
<span class="sd">            to read. If not provided (default) all bands are loaded.</span>
<span class="sd">            Ignored if `band_names_src` is provided.</span>
<span class="sd">        :param band_names_src:</span>
<span class="sd">            optional list of band names in the raster dataset to</span>
<span class="sd">            read. If not provided (default) all bands are loaded. If</span>
<span class="sd">            `band_idxs` and `band_names_src` are provided, the former</span>
<span class="sd">            is ignored.</span>
<span class="sd">        :param band_names_dst:</span>
<span class="sd">            optional list of band names in the resulting collection.</span>
<span class="sd">            Must match the length and order of `band_idxs` or</span>
<span class="sd">            `band_names_src`</span>
<span class="sd">        :returns:</span>
<span class="sd">            dictionary with band indices, and names based on the custom</span>
<span class="sd">            selection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check band selection</span>
        <span class="n">band_names</span><span class="p">,</span> <span class="n">band_count</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">band_idxs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fpath_raster</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">band_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">fpath_raster</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="n">band_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">band_names</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">with</span> <span class="n">rio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fpath_raster</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
                        <span class="n">band_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">descriptions</span><span class="p">)</span>
                        <span class="n">band_count</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">count</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not read </span><span class="si">{</span><span class="n">fpath_raster</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># use default band names if not provided in data set</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">band_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">band_names_src</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;B</span><span class="si">{</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">band_count</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">band_names_src</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">band_names_src</span> <span class="o">=</span> <span class="n">band_names</span>
            <span class="c1"># is a selection of bands provided? If no use all available bands</span>
            <span class="c1"># otherwise check the band indices</span>
            <span class="k">if</span> <span class="n">band_names_src</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">set</span><span class="p">(</span><span class="n">band_names_src</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="kc">None</span><span class="p">}:</span>
                <span class="c1"># get band indices of all bands, add 1 since GDAL starts</span>
                <span class="c1"># counting at 1</span>
                <span class="n">band_idxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">band_count</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># get band indices of selected bands (+1 because of GDAL)</span>
                <span class="n">band_idxs</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">band_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">band_names_src</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">band_names</span>
                <span class="p">]</span>

        <span class="n">band_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">band_idxs</span><span class="p">)</span>
        <span class="c1"># make sure neither band_idxs nor band_names_src is None or empty</span>
        <span class="k">if</span> <span class="n">band_idxs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">band_idxs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No band indices could be determined&quot;</span><span class="p">)</span>

        <span class="c1"># make sure band_names_src are set</span>
        <span class="k">if</span> <span class="n">band_names_src</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">set</span><span class="p">(</span><span class="n">band_names_src</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="kc">None</span><span class="p">}:</span>
            <span class="n">band_names_src</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;B</span><span class="si">{</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">band_count</span><span class="p">)]</span>

        <span class="c1"># set band_names_dst to values of band_names_src or default names</span>
        <span class="k">if</span> <span class="n">band_names_dst</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">set</span><span class="p">(</span><span class="n">band_names_src</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="kc">None</span><span class="p">}:</span>
            <span class="n">band_names_dst</span> <span class="o">=</span> <span class="n">band_names_src</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;band_idxs&quot;</span><span class="p">:</span> <span class="n">band_idxs</span><span class="p">,</span>
            <span class="s2">&quot;band_names_src&quot;</span><span class="p">:</span> <span class="n">band_names_src</span><span class="p">,</span>
            <span class="s2">&quot;band_names_dst&quot;</span><span class="p">:</span> <span class="n">band_names_dst</span><span class="p">,</span>
            <span class="s2">&quot;band_count&quot;</span><span class="p">:</span> <span class="n">band_count</span><span class="p">,</span>
        <span class="p">}</span>

<div class="viewcode-block" id="RasterCollection.apply"><a class="viewcode-back" href="../../../packages/eodal.core.raster.html#eodal.core.raster.RasterCollection.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a custom function to a ``RasterCollection``.</span>

<span class="sd">        :param func:</span>
<span class="sd">            custom callable taking the ``RasterCollection`` as first</span>
<span class="sd">            argument</span>
<span class="sd">        :param args:</span>
<span class="sd">            optional arguments to pass to `func`</span>
<span class="sd">        :param kwargs:</span>
<span class="sd">            optional keyword arguments to pass to `func`</span>
<span class="sd">        :returns:</span>
<span class="sd">            results of `func`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">func</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span> <span class="kn">from</span> <span class="nn">e</span></div>

<div class="viewcode-block" id="RasterCollection.copy"><a class="viewcode-back" href="../../../packages/eodal.core.raster.html#eodal.core.raster.RasterCollection.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of the current ``RasterCollection``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="RasterCollection.from_multi_band_raster"><a class="viewcode-back" href="../../../packages/eodal.core.raster.html#eodal.core.raster.RasterCollection.from_multi_band_raster">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_multi_band_raster</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">fpath_raster</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span>
        <span class="n">band_idxs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">band_names_src</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">band_names_dst</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">band_aliases</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads bands from a multi-band raster file into a new</span>
<span class="sd">        `RasterCollection` instance.</span>

<span class="sd">        Wrapper around `~eodal.core.Band.from_rasterio` for</span>
<span class="sd">        1 to N raster bands.</span>

<span class="sd">        :param fpath_raster:</span>
<span class="sd">            file-path to the raster file (technically spoken, this</span>
<span class="sd">            can also have just a single band)</span>
<span class="sd">        :param band_idxs:</span>
<span class="sd">            optional list of band indices in the raster dataset</span>
<span class="sd">            to read. If not provided (default) all bands are loaded.</span>
<span class="sd">            Ignored if `band_names_src` is provided.</span>
<span class="sd">        :param band_names_src:</span>
<span class="sd">            optional list of band names in the raster dataset to</span>
<span class="sd">            read. If not provided (default) all bands are loaded. If</span>
<span class="sd">            `band_idxs` and `band_names_src` are provided, the former</span>
<span class="sd">            is ignored.</span>
<span class="sd">        :param band_names_dst:</span>
<span class="sd">            optional list of band names in the resulting collection.</span>
<span class="sd">            Must match the length and order of `band_idxs` or</span>
<span class="sd">            `band_names_src`</span>
<span class="sd">        :param band_aliases:</span>
<span class="sd">            optional list of aliases to use for *aliasing* of band names</span>
<span class="sd">        :param kwargs:</span>
<span class="sd">            optional key-word arguments accepted by</span>
<span class="sd">            `~eodal.core.Band.from_rasterio`</span>
<span class="sd">        :returns:</span>
<span class="sd">            `RasterCollection` instance with loaded bands from the</span>
<span class="sd">            input raster data set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check band selection</span>
        <span class="n">band_props</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_bands_from_selection</span><span class="p">(</span>
            <span class="n">fpath_raster</span><span class="o">=</span><span class="n">fpath_raster</span><span class="p">,</span>
            <span class="n">band_idxs</span><span class="o">=</span><span class="n">band_idxs</span><span class="p">,</span>
            <span class="n">band_names_src</span><span class="o">=</span><span class="n">band_names_src</span><span class="p">,</span>
            <span class="n">band_names_dst</span><span class="o">=</span><span class="n">band_names_dst</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># make sure band aliases match the length of bands</span>
        <span class="k">if</span> <span class="n">band_aliases</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">band_aliases</span><span class="p">)</span> <span class="o">!=</span> <span class="n">band_props</span><span class="p">[</span><span class="s2">&quot;band_count&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Number of band_aliases (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">band_aliases</span><span class="p">)</span><span class="si">}</span><span class="s2">) does &quot;</span>
                    <span class="sa">f</span><span class="s1">&#39;not match number of bands to load (</span><span class="si">{</span><span class="n">band_props</span><span class="p">[</span><span class="s2">&quot;band_count&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">)&#39;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">band_aliases</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">band_props</span><span class="p">[</span><span class="s2">&quot;band_count&quot;</span><span class="p">])]</span>

        <span class="c1"># loop over the bands and add them to an empty handler</span>
        <span class="n">handler</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">band_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">band_props</span><span class="p">[</span><span class="s2">&quot;band_count&quot;</span><span class="p">]):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">handler</span><span class="o">.</span><span class="n">add_band</span><span class="p">(</span>
                    <span class="n">Band</span><span class="o">.</span><span class="n">from_rasterio</span><span class="p">,</span>
                    <span class="n">fpath_raster</span><span class="o">=</span><span class="n">fpath_raster</span><span class="p">,</span>
                    <span class="n">band_idx</span><span class="o">=</span><span class="n">band_props</span><span class="p">[</span><span class="s2">&quot;band_idxs&quot;</span><span class="p">][</span><span class="n">band_idx</span><span class="p">],</span>
                    <span class="n">band_name_dst</span><span class="o">=</span><span class="n">band_props</span><span class="p">[</span><span class="s2">&quot;band_names_dst&quot;</span><span class="p">][</span><span class="n">band_idx</span><span class="p">],</span>
                    <span class="n">band_alias</span><span class="o">=</span><span class="n">band_aliases</span><span class="p">[</span><span class="n">band_idx</span><span class="p">],</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Could not add band </span><span class="si">{</span><span class="n">band_names_src</span><span class="p">[</span><span class="n">band_idx</span><span class="p">]</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;from </span><span class="si">{</span><span class="n">fpath_raster</span><span class="si">}</span><span class="s2"> to handler: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">handler</span></div>

<div class="viewcode-block" id="RasterCollection.read_pixels"><a class="viewcode-back" href="../../../packages/eodal.core.raster.html#eodal.core.raster.RasterCollection.read_pixels">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read_pixels</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">fpath_raster</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span>
        <span class="n">vector_features</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Path</span><span class="p">,</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">],</span>
        <span class="n">band_idxs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">band_names_src</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">band_names_dst</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper around `~eodal.core.band.read_pixels` for raster datasets</span>
<span class="sd">        with multiple bands</span>

<span class="sd">        NOTE:</span>
<span class="sd">            The pixels to read are defined by a ``GeoDataFrame`` or file with</span>
<span class="sd">            vector features understood by ``fiona``. If the geometry type is not</span>
<span class="sd">            ``Point`` the centroids will be used for extracting the closest</span>
<span class="sd">            grid cell value.</span>

<span class="sd">        :param fpath_raster:</span>
<span class="sd">            file-path to the raster dataset from which to extract pixel values</span>
<span class="sd">        :param vector_features:</span>
<span class="sd">            file-path or ``GeoDataFrame`` to features defining the pixels to read</span>
<span class="sd">            from a raster dataset. The geometries can be of type ``Point``,</span>
<span class="sd">            ``Polygon`` or ``MultiPolygon``. In the latter two cases the centroids</span>
<span class="sd">            are used to extract pixel values, whereas for point features the</span>
<span class="sd">            closest raster grid cell is selected.</span>
<span class="sd">        ::param band_idxs:</span>
<span class="sd">            optional list of band indices in the raster dataset to read. If not</span>
<span class="sd">            provided (default) all bands are loaded. Ignored if `band_names_src` is</span>
<span class="sd">            provided.</span>
<span class="sd">        :param band_names_src:</span>
<span class="sd">            optional list of band names in the raster dataset to read. If not provided</span>
<span class="sd">            (default) all bands are loaded. If `band_idxs` and `band_names_src` are</span>
<span class="sd">            provided, the former is ignored.</span>
<span class="sd">        :param band_names_dst:</span>
<span class="sd">            optional list of band names in the resulting collection.Must match the</span>
<span class="sd">            length and order of `band_idxs` or `band_names_src`.</span>
<span class="sd">        :returns:</span>
<span class="sd">            ``GeoDataFrame`` with extracted pixel values. If the vector features</span>
<span class="sd">            defining the sampling points are not within the spatial extent of the</span>
<span class="sd">            raster dataset the pixel values are set to nodata (inferred from</span>
<span class="sd">            the raster source)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check band selection</span>
        <span class="n">band_props</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_bands_from_selection</span><span class="p">(</span>
            <span class="n">fpath_raster</span><span class="o">=</span><span class="n">fpath_raster</span><span class="p">,</span>
            <span class="n">band_idxs</span><span class="o">=</span><span class="n">band_idxs</span><span class="p">,</span>
            <span class="n">band_names_src</span><span class="o">=</span><span class="n">band_names_src</span><span class="p">,</span>
            <span class="n">band_names_dst</span><span class="o">=</span><span class="n">band_names_dst</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># loop over bands and extract values from raster dataset</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">band_props</span><span class="p">[</span><span class="s2">&quot;band_count&quot;</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">gdf</span> <span class="o">=</span> <span class="n">Band</span><span class="o">.</span><span class="n">read_pixels</span><span class="p">(</span>
                    <span class="n">fpath_raster</span><span class="o">=</span><span class="n">fpath_raster</span><span class="p">,</span>
                    <span class="n">vector_features</span><span class="o">=</span><span class="n">vector_features</span><span class="p">,</span>
                    <span class="n">band_idx</span><span class="o">=</span><span class="n">band_props</span><span class="p">[</span><span class="s2">&quot;band_idxs&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span>
                    <span class="n">band_name_src</span><span class="o">=</span><span class="n">band_props</span><span class="p">[</span><span class="s2">&quot;band_names_src&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span>
                    <span class="n">band_name_dst</span><span class="o">=</span><span class="n">band_props</span><span class="p">[</span><span class="s2">&quot;band_names_dst&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gdf</span> <span class="o">=</span> <span class="n">Band</span><span class="o">.</span><span class="n">read_pixels</span><span class="p">(</span>
                    <span class="n">fpath_raster</span><span class="o">=</span><span class="n">fpath_raster</span><span class="p">,</span>
                    <span class="n">vector_features</span><span class="o">=</span><span class="n">gdf</span><span class="p">,</span>
                    <span class="n">band_idx</span><span class="o">=</span><span class="n">band_props</span><span class="p">[</span><span class="s2">&quot;band_idxs&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span>
                    <span class="n">band_name_src</span><span class="o">=</span><span class="n">band_props</span><span class="p">[</span><span class="s2">&quot;band_names_src&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span>
                    <span class="n">band_name_dst</span><span class="o">=</span><span class="n">band_props</span><span class="p">[</span><span class="s2">&quot;band_names_dst&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">gdf</span></div>

<div class="viewcode-block" id="RasterCollection.drop_band"><a class="viewcode-back" href="../../../packages/eodal.core.raster.html#eodal.core.raster.RasterCollection.drop_band">[docs]</a>    <span class="nd">@check_band_names</span>
    <span class="k">def</span> <span class="nf">drop_band</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">band_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deletes a band from the current collection</span>

<span class="sd">        :param band_name:</span>
<span class="sd">            name of the band to drop</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ensure band aliases get deleted as well</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_band_aliases</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">band_name</span><span class="p">]</span><span class="o">.</span><span class="n">alias</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_aliases</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_band_aliases</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">band_name</span><span class="p">]</span><span class="o">.</span><span class="n">alias</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="n">band_name</span><span class="p">)</span></div>

<div class="viewcode-block" id="RasterCollection.is_bandstack"><a class="viewcode-back" href="../../../packages/eodal.core.raster.html#eodal.core.raster.RasterCollection.is_bandstack">[docs]</a>    <span class="k">def</span> <span class="nf">is_bandstack</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">band_selection</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the rasters handled in the collection fulfill the bandstack</span>
<span class="sd">        criteria.</span>

<span class="sd">        These criteria are:</span>
<span class="sd">            - all bands have the same CRS</span>
<span class="sd">            - all bands have the same x and y dimension (number of rows and columns)</span>
<span class="sd">            - all bands must have the same upper left corner coordinates</span>

<span class="sd">        :param band_selection:</span>
<span class="sd">            if not None, checks only a list of selected bands. By default,</span>
<span class="sd">            all bands of the current object are checked.</span>
<span class="sd">        :returns:</span>
<span class="sd">            True if the current object fulfills the criteria else False;</span>
<span class="sd">            None if no bands are loaded into the handler&#39;s collection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">band_selection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">band_selection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_names</span>

        <span class="c1"># return None if no bands are in collection</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># otherwise use the first band (that will then always exist)</span>
        <span class="c1"># as reference to check the other bands (if any) against</span>
        <span class="n">first_geo_info</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">band_selection</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">geo_info</span>
        <span class="n">first_shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">band_selection</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">nrows</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">band_selection</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">ncols</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">band_selection</span><span class="p">)):</span>
            <span class="n">this_geo_info</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">band_selection</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span><span class="o">.</span><span class="n">geo_info</span>
            <span class="n">this_shape</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">band_selection</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span><span class="o">.</span><span class="n">nrows</span><span class="p">,</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">band_selection</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span><span class="o">.</span><span class="n">ncols</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">this_shape</span> <span class="o">!=</span> <span class="n">first_shape</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">this_geo_info</span><span class="o">.</span><span class="n">epsg</span> <span class="o">!=</span> <span class="n">first_geo_info</span><span class="o">.</span><span class="n">epsg</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">this_geo_info</span><span class="o">.</span><span class="n">ulx</span> <span class="o">!=</span> <span class="n">first_geo_info</span><span class="o">.</span><span class="n">ulx</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">this_geo_info</span><span class="o">.</span><span class="n">uly</span> <span class="o">!=</span> <span class="n">first_geo_info</span><span class="o">.</span><span class="n">uly</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">this_geo_info</span><span class="o">.</span><span class="n">pixres_x</span> <span class="o">!=</span> <span class="n">first_geo_info</span><span class="o">.</span><span class="n">pixres_x</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">this_geo_info</span><span class="o">.</span><span class="n">pixres_y</span> <span class="o">!=</span> <span class="n">first_geo_info</span><span class="o">.</span><span class="n">pixres_y</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="RasterCollection.add_band"><a class="viewcode-back" href="../../../packages/eodal.core.raster.html#eodal.core.raster.RasterCollection.add_band">[docs]</a>    <span class="k">def</span> <span class="nf">add_band</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">band_constructor</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Band</span><span class="p">],</span> <span class="n">Band</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a band to the collection of raster bands.</span>

<span class="sd">        Raises an error if a band with the same name already exists (unique</span>
<span class="sd">        name constraint)</span>

<span class="sd">        :param band_constructor:</span>
<span class="sd">            callable returning a `~eodal.core.Band` instance or existing</span>
<span class="sd">            `Band` instance</span>
<span class="sd">        :param args:</span>
<span class="sd">            arguments to pass to `band_constructor` or one of its</span>
<span class="sd">            class methods (`Band.from_rasterio`, `Band.from_vector`)</span>
<span class="sd">        :param kwargs:</span>
<span class="sd">            key-word arguments to pass to `band_constructor`  or one of its</span>
<span class="sd">            class methods (`Band.from_rasterio`, `Band.from_vector`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">band_constructor</span><span class="p">,</span> <span class="n">Band</span><span class="p">):</span>
                <span class="n">band</span> <span class="o">=</span> <span class="n">band_constructor</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">band</span> <span class="o">=</span> <span class="n">band_constructor</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot initialize new Band instance: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">band</span><span class="p">)</span>
            <span class="c1"># forward band alias if any</span>
            <span class="k">if</span> <span class="n">band</span><span class="o">.</span><span class="n">has_alias</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_band_aliases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">band</span><span class="o">.</span><span class="n">band_alias</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot add raster band: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="RasterCollection.clip_bands"><a class="viewcode-back" href="../../../packages/eodal.core.raster.html#eodal.core.raster.RasterCollection.clip_bands">[docs]</a>    <span class="nd">@check_band_names</span>
    <span class="k">def</span> <span class="nf">clip_bands</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">band_selection</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clip bands in RasterCollection to a user-defined spatial bounds.</span>

<span class="sd">        :param band_selection:</span>
<span class="sd">            optional list of bands to clip. If not provided takes all available</span>
<span class="sd">            bands.</span>
<span class="sd">        :param inplace:</span>
<span class="sd">            if False (default) returns a copy of the ``RasterCollection`` instance</span>
<span class="sd">            with the changes applied. If True overwrites the values</span>
<span class="sd">            in the current instance.</span>
<span class="sd">        :param **kwargs:</span>
<span class="sd">            key-word arguments to pass to `Band.clip` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">band_selection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">band_selection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_names</span>
        <span class="c1"># loop over bands and try to subset them spatially</span>
        <span class="c1"># initialize a new raster collection if inplace is False</span>
        <span class="n">collection</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;inplace&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_collection&quot;</span><span class="p">)</span>
            <span class="n">collection</span> <span class="o">=</span> <span class="n">RasterCollection</span><span class="p">(</span><span class="o">**</span><span class="n">attrs</span><span class="p">)</span>

        <span class="c1"># loop over band reproject the selected ones</span>
        <span class="k">for</span> <span class="n">band_name</span> <span class="ow">in</span> <span class="n">band_selection</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">collection</span><span class="p">[</span><span class="n">band_name</span><span class="p">]</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">band</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_band</span><span class="p">(</span><span class="n">band_name</span><span class="p">)</span>
                <span class="n">collection</span><span class="o">.</span><span class="n">add_band</span><span class="p">(</span><span class="n">band_constructor</span><span class="o">=</span><span class="n">band</span><span class="o">.</span><span class="n">clip</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">collection</span></div>

<div class="viewcode-block" id="RasterCollection.plot_band"><a class="viewcode-back" href="../../../packages/eodal.core.raster.html#eodal.core.raster.RasterCollection.plot_band">[docs]</a>    <span class="nd">@check_band_names</span>
    <span class="k">def</span> <span class="nf">plot_band</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">band_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Figure</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots a band in the collection of raster bands.</span>

<span class="sd">        Wrapper method around `~eodal.core.Band.plot`.</span>

<span class="sd">        :param band_name:</span>
<span class="sd">            name of the band to plot. Aliasing is supported.</span>
<span class="sd">        :param kwargs:</span>
<span class="sd">            key-word arguments to pass to `~eodal.core.Band.plot`</span>
<span class="sd">        :returns:</span>
<span class="sd">            `~matplotlib.pyplot.Figure` with band plotted as map</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">band_name</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="RasterCollection.plot_multiple_bands"><a class="viewcode-back" href="../../../packages/eodal.core.raster.html#eodal.core.raster.RasterCollection.plot_multiple_bands">[docs]</a>    <span class="nd">@check_band_names</span>
    <span class="k">def</span> <span class="nf">plot_multiple_bands</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">band_selection</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ax</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Axes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">nodata_color</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;white&#39;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots three selected bands in a pseudo RGB with 8bit color-depth.</span>

<span class="sd">        IMPORTANT:</span>
<span class="sd">            The bands to plot **must** have the same spatial resolution,</span>
<span class="sd">            extent and CRS</span>

<span class="sd">        :param band_selection:</span>
<span class="sd">            optional list of bands to plot. If not provided takes the</span>
<span class="sd">            first three bands (or less) to plot</span>
<span class="sd">        :param ax:</span>
<span class="sd">            optional `matplotlib.axes` object to plot onto</span>
<span class="sd">        :param nodata_color:</span>
<span class="sd">            ..versionadd:: 0.2.1</span>
<span class="sd">            Color no-data (masked) pixels should take in the RGB plot.</span>
<span class="sd">            Default is &#39;white&#39;. All color names supported by</span>
<span class="sd">            `~matplotlib.colors` can be passed.  </span>
<span class="sd">        :returns:</span>
<span class="sd">            `~matplotlib.pyplot.Figure` with band plotted as map in</span>
<span class="sd">            8bit color depth</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check passed band_selection</span>
        <span class="k">if</span> <span class="n">band_selection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">band_selection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_names</span>
        <span class="c1"># if one band was passed only call plot band</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">band_selection</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_band</span><span class="p">(</span><span class="n">band_name</span><span class="o">=</span><span class="n">band_selection</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># if too many bands are passed take the first three</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">band_selection</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">band_selection</span> <span class="o">=</span> <span class="n">band_selection</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="c1"># but raise an error when less than three bands are available</span>
        <span class="c1"># unless it&#39;s</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">band_selection</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need three bands to plot&quot;</span><span class="p">)</span>

        <span class="c1"># check if data can be stacked</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bandstack</span><span class="p">(</span><span class="n">band_selection</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Bands to plot must share same spatial extent, pixel size and CRS&quot;</span>
            <span class="p">)</span>

        <span class="c1"># get bounds in the spatial coordinate system for plotting</span>
        <span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">band_selection</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">bounds</span>
        <span class="c1"># determine intervals for plotting and aspect ratio (figsize)</span>
        <span class="n">east_west_dim</span> <span class="o">=</span> <span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">east_west_dim</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="p">:</span>
            <span class="n">x_interval</span> <span class="o">=</span> <span class="mi">500</span>
        <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">east_west_dim</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">5000</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">east_west_dim</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="p">:</span>
            <span class="n">x_interval</span> <span class="o">=</span> <span class="mi">5000</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x_interval</span> <span class="o">=</span> <span class="mi">50000</span>
        <span class="n">north_south_dim</span> <span class="o">=</span> <span class="n">ymax</span> <span class="o">-</span> <span class="n">ymin</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">north_south_dim</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="p">:</span>
            <span class="n">y_interval</span> <span class="o">=</span> <span class="mi">500</span>
        <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">north_south_dim</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">5000</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">north_south_dim</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="p">:</span>
            <span class="n">y_interval</span> <span class="o">=</span> <span class="mi">5000</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y_interval</span> <span class="o">=</span> <span class="mi">50000</span>

        <span class="c1"># clip values to 8bit color depth</span>
        <span class="n">array_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">masked</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">band_name</span> <span class="ow">in</span> <span class="n">band_selection</span><span class="p">:</span>
            <span class="n">band_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_band</span><span class="p">(</span><span class="n">band_name</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">new_arr</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">band_data</span> <span class="o">-</span> <span class="n">band_data</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
                <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">band_data</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">band_data</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">*</span> <span class="mi">255</span><span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;uint8&quot;</span><span class="p">)</span>
            <span class="n">array_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_arr</span><span class="p">)</span>
            <span class="n">masked</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">new_arr</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">))</span>
        <span class="c1"># stack arrays into 3d array</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">masked</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span><span class="n">array_list</span><span class="p">)</span>
            <span class="c1"># set masked values to zero reflectance</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">stack</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span><span class="n">array_list</span><span class="p">)</span>
        <span class="c1"># get quantiles to improve plot visibility</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanquantile</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanquantile</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">)</span>

        <span class="c1"># get new axis and figure or figure from existing axis</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_figure</span><span class="p">()</span>

        <span class="c1"># ..versionadd:: 0.2.1</span>
        <span class="c1"># set color of nodata values [0,0,0] to custom RGB value</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">nodata_color_rgb</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">colors</span><span class="o">.</span><span class="n">to_rgb</span><span class="p">(</span><span class="n">nodata_color</span><span class="p">))</span>
            <span class="n">nodata_color_rgb</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="mi">255</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nodata_color_rgb</span><span class="p">]</span>
            
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">nodata_color</span><span class="si">}</span><span class="s1"> is not a recognized color name.&#39;</span> <span class="o">+</span>
                <span class="s1">&#39; Using default &quot;white&quot; instead.&#39;</span><span class="p">)</span>
            <span class="n">nodata_color_rgb</span> <span class="o">=</span> <span class="p">[</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">]</span>
        <span class="c1"># get nodata values ([0,0,0]) and replace them with the custom</span>
        <span class="c1"># RGB value</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">stack</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodata_color_rgb</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">])</span>
        <span class="c1"># set axis labels</span>
        <span class="n">epsg</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">band_selection</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">geo_info</span><span class="o">.</span><span class="n">epsg</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">band_selection</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">is_geographic</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="s2">&quot;deg&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="p">[</span><span class="n">band_selection</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">is_projected</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="s2">&quot;m&quot;</span>
        <span class="n">fontsize</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fontsize&quot;</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;X [</span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">] (EPSG:</span><span class="si">{</span><span class="n">epsg</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">x_interval</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Y [</span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">] (EPSG:</span><span class="si">{</span><span class="n">epsg</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">y_interval</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_major_formatter</span><span class="p">(</span><span class="n">ticker</span><span class="o">.</span><span class="n">FormatStrFormatter</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%.0f</span><span class="s2">&quot;</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_major_formatter</span><span class="p">(</span><span class="n">ticker</span><span class="o">.</span><span class="n">FormatStrFormatter</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%.0f</span><span class="s2">&quot;</span><span class="p">))</span>

        <span class="c1"># add title str</span>
        <span class="n">title_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">band_selection</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title_str</span><span class="p">,</span> <span class="n">fontdict</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fontsize&quot;</span><span class="p">:</span> <span class="n">fontsize</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">fig</span></div>

<div class="viewcode-block" id="RasterCollection.get_band"><a class="viewcode-back" href="../../../packages/eodal.core.raster.html#eodal.core.raster.RasterCollection.get_band">[docs]</a>    <span class="nd">@check_band_names</span>
    <span class="k">def</span> <span class="nf">get_band</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">band_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Band</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a single band from the collection or None</span>
<span class="sd">        if the band is not found.</span>

<span class="sd">        :param band_name:</span>
<span class="sd">            band name (or its alias) to return</span>
<span class="sd">        :returns:</span>
<span class="sd">            ``Band`` instance from band name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">band_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>

    <span class="c1"># @check_band_names</span>
<div class="viewcode-block" id="RasterCollection.get_pixels"><a class="viewcode-back" href="../../../packages/eodal.core.raster.html#eodal.core.raster.RasterCollection.get_pixels">[docs]</a>    <span class="k">def</span> <span class="nf">get_pixels</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">vector_features</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Path</span><span class="p">,</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">],</span>
        <span class="n">band_selection</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns pixel values from bands in the collection as ``GeoDataFrame``.</span>

<span class="sd">        Since a pixel is a dimensionless object (``Point``) the extraction</span>
<span class="sd">        method works for raster bands with different pixel sizes, spatial</span>
<span class="sd">        extent and coordinate systems. If a pixel cannot be extracted from a</span>
<span class="sd">        raster band, the band&#39;s nodata value is inserted.</span>

<span class="sd">        :param band_selection:</span>
<span class="sd">            optional selection of bands to return</span>
<span class="sd">        :param vector_features:</span>
<span class="sd">            file-path or ``GeoDataFrame`` to features defining the pixels to read</span>
<span class="sd">            from the raster bands selected. The geometries can be of type ``Point``,</span>
<span class="sd">            ``Polygon`` or ``MultiPolygon``. In the latter two cases the centroids</span>
<span class="sd">            are used to extract pixel values, whereas for point features the</span>
<span class="sd">            closest raster grid cell is selected.</span>
<span class="sd">        :returns:</span>
<span class="sd">            ``GeoDataFrame`` with extracted raster values per pixel or</span>
<span class="sd">            Polygon centroid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">band_selection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">band_selection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_names</span>

        <span class="c1"># loop over bands and extract the raster values into a GeoDataFrame</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">band_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">band_selection</span><span class="p">):</span>
            <span class="c1"># open a new GeoDataFrame for the first band and re-use it for</span>
            <span class="c1"># the other bands. This way we do not have to merge the single</span>
            <span class="c1"># GeoDataFrames afterwards</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">gdf</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">band_name</span><span class="p">]</span><span class="o">.</span><span class="n">get_pixels</span><span class="p">(</span><span class="n">vector_features</span><span class="o">=</span><span class="n">vector_features</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gdf</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">band_name</span><span class="p">]</span><span class="o">.</span><span class="n">get_pixels</span><span class="p">(</span><span class="n">vector_features</span><span class="o">=</span><span class="n">gdf</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">gdf</span></div>

<div class="viewcode-block" id="RasterCollection.get_values"><a class="viewcode-back" href="../../../packages/eodal.core.raster.html#eodal.core.raster.RasterCollection.get_values">[docs]</a>    <span class="nd">@check_band_names</span>
    <span class="k">def</span> <span class="nf">get_values</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">band_selection</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns raster values as stacked array in collection.</span>

<span class="sd">        NOTE:</span>
<span class="sd">            The selection of bands to return as stacked array</span>
<span class="sd">            **must** share the same spatial extent, pixel size</span>
<span class="sd">            and coordinate system</span>

<span class="sd">        :param band_selection:</span>
<span class="sd">            optional selection of bands to return</span>
<span class="sd">        :returns:</span>
<span class="sd">            raster band values in their underlying storage</span>
<span class="sd">            type (``numpy.ndarray``, ``numpy.ma.MaskedArray``,</span>
<span class="sd">            ``zarr``)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">band_selection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">band_selection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_names</span>

        <span class="c1"># check if the selected bands have the same spatial extent, pixel</span>
        <span class="c1"># cell size and spatial coordinate system (if not stacking fails)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bandstack</span><span class="p">(</span><span class="n">band_selection</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot stack raster bands - they do not align spatially &quot;</span>
                <span class="s2">&quot;to each other.</span><span class="se">\n</span><span class="s2">Consider reprojection/ resampling first.&quot;</span>
            <span class="p">)</span>

        <span class="n">stack_bands</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_band</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">values</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">band_selection</span><span class="p">]</span>
        <span class="n">array_types</span> <span class="o">=</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">stack_bands</span><span class="p">]</span>

        <span class="c1"># stack arrays along first axis</span>
        <span class="c1"># we need np.ma in case the array is a masked array</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">array_types</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">}:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">stack_bands</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">set</span><span class="p">(</span><span class="n">array_types</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">}:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">stack_bands</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">set</span><span class="p">(</span><span class="n">array_types</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">}:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">stack_bands</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">set</span><span class="p">(</span><span class="n">array_types</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="n">zarr</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Array</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported array type&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="RasterCollection.band_summaries"><a class="viewcode-back" href="../../../packages/eodal.core.raster.html#eodal.core.raster.RasterCollection.band_summaries">[docs]</a>    <span class="nd">@check_band_names</span>
    <span class="k">def</span> <span class="nf">band_summaries</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">band_selection</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Descriptive band statistics by calling `Band.reduce` for bands in a collection.</span>

<span class="sd">        :param band_selection:</span>
<span class="sd">            selection of bands to process. If not provided uses all</span>
<span class="sd">            bands</span>
<span class="sd">        :param kwargs:</span>
<span class="sd">            optional keyword arguments to pass to `~eodal.core.band.Band.reduce`. Use</span>
<span class="sd">            `by` to get descriptive statistics by selected geometry features (e.g.,</span>
<span class="sd">            single polygons).</span>
<span class="sd">        :returns:</span>
<span class="sd">            ``GeoDataFrame`` with descriptive statistics for all bands selected and</span>
<span class="sd">            geometry features passed (optional)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">band_selection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">band_selection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_names</span>
        <span class="k">for</span> <span class="n">band_name</span> <span class="ow">in</span> <span class="n">band_selection</span><span class="p">:</span>
            <span class="n">band_stats</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">band_name</span><span class="p">]</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="c1"># band_stats is a list of 1:N entries (one per feature on which reduce</span>
            <span class="c1"># was called); we add the band name as attribute</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">band_stats</span><span class="p">)):</span>
                <span class="n">band_stats</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;band_name&quot;</span><span class="p">:</span> <span class="n">band_name</span><span class="p">})</span>
            <span class="n">stats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">band_stats</span><span class="p">)</span>
        <span class="c1"># since the geometry information was passed on, a GeoDataFrame can be returned</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">stats</span><span class="p">)))</span>
        <span class="c1"># check if the returned DataFrame is empty. In this case return an empty</span>
        <span class="c1"># GeoDataFrame</span>
        <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">()</span>

        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">],</span> <span class="n">crs</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;crs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># cast columns to float; otherwise pandas throws an error:</span>
        <span class="c1"># TypeError: unhashable type: &#39;MaskedConstant&#39;</span>
        <span class="n">methods</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;method&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;min&quot;</span><span class="p">,</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;std&quot;</span><span class="p">,</span> <span class="s2">&quot;max&quot;</span><span class="p">,</span> <span class="s2">&quot;count&quot;</span><span class="p">])</span>
        <span class="c1"># check if method contains callable functions</span>
        <span class="n">cleaned_methods</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">methods</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
                <span class="n">cleaned_methods</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cleaned_methods</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        <span class="n">gdf</span><span class="p">[</span><span class="n">cleaned_methods</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">cleaned_methods</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">gdf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;crs&quot;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gdf</span></div>

<div class="viewcode-block" id="RasterCollection.reproject"><a class="viewcode-back" href="../../../packages/eodal.core.raster.html#eodal.core.raster.RasterCollection.reproject">[docs]</a>    <span class="nd">@check_band_names</span>
    <span class="k">def</span> <span class="nf">reproject</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">band_selection</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reprojects band in the collection from one coordinate system</span>
<span class="sd">        into another</span>

<span class="sd">        :param band_selection:</span>
<span class="sd">            selection of bands to process. If not provided uses all</span>
<span class="sd">            bands</span>
<span class="sd">        :param inplace:</span>
<span class="sd">            if False returns a new `RasterCollection` (default) otherwise</span>
<span class="sd">            overwrites existing raster band entries</span>
<span class="sd">        :param kwargs:</span>
<span class="sd">            key-word arguments to pass to `~eodal.core.Band.reproject`</span>
<span class="sd">        :returns:</span>
<span class="sd">            new RasterCollection if `inplace==False`, None otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">band_selection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">band_selection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_names</span>
        <span class="c1"># initialize a new raster collection if inplace is False</span>
        <span class="n">collection</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;inplace&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_collection&quot;</span><span class="p">)</span>
            <span class="n">collection</span> <span class="o">=</span> <span class="n">RasterCollection</span><span class="p">(</span><span class="o">**</span><span class="n">attrs</span><span class="p">)</span>

        <span class="c1"># loop over band reproject the selected ones</span>
        <span class="k">for</span> <span class="n">band_name</span> <span class="ow">in</span> <span class="n">band_selection</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">collection</span><span class="p">[</span><span class="n">band_name</span><span class="p">]</span><span class="o">.</span><span class="n">reproject</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">band</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_band</span><span class="p">(</span><span class="n">band_name</span><span class="p">)</span>
                <span class="n">collection</span><span class="o">.</span><span class="n">add_band</span><span class="p">(</span><span class="n">band_constructor</span><span class="o">=</span><span class="n">band</span><span class="o">.</span><span class="n">reproject</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">collection</span></div>

<div class="viewcode-block" id="RasterCollection.resample"><a class="viewcode-back" href="../../../packages/eodal.core.raster.html#eodal.core.raster.RasterCollection.resample">[docs]</a>    <span class="nd">@check_band_names</span>
    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">band_selection</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resamples band in the collection into a different spatial resolution</span>

<span class="sd">        :param band_selection:</span>
<span class="sd">            selection of bands to process. If not provided uses all</span>
<span class="sd">            bands</span>
<span class="sd">        :param inplace:</span>
<span class="sd">            if False returns a new `RasterCollection` (default) otherwise</span>
<span class="sd">            overwrites existing raster band entries</span>
<span class="sd">        :param kwargs:</span>
<span class="sd">            key-word arguments to pass to `~eodal.core.Band.resample`</span>
<span class="sd">        :returns:</span>
<span class="sd">            new RasterCollection if `inplace==False`, None otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">band_selection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">band_selection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_names</span>
        <span class="c1"># initialize a new raster collection if inplace is False</span>
        <span class="n">collection</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;inplace&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_collection&quot;</span><span class="p">)</span>
            <span class="n">collection</span> <span class="o">=</span> <span class="n">RasterCollection</span><span class="p">(</span><span class="o">**</span><span class="n">attrs</span><span class="p">)</span>

        <span class="c1"># loop over band reproject the selected ones</span>
        <span class="k">for</span> <span class="n">band_name</span> <span class="ow">in</span> <span class="n">band_selection</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">collection</span><span class="p">[</span><span class="n">band_name</span><span class="p">]</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">band</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_band</span><span class="p">(</span><span class="n">band_name</span><span class="p">)</span>
                <span class="n">collection</span><span class="o">.</span><span class="n">add_band</span><span class="p">(</span><span class="n">band_constructor</span><span class="o">=</span><span class="n">band</span><span class="o">.</span><span class="n">resample</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">collection</span></div>

<div class="viewcode-block" id="RasterCollection.mask"><a class="viewcode-back" href="../../../packages/eodal.core.raster.html#eodal.core.raster.RasterCollection.mask">[docs]</a>    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mask</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Band</span><span class="p">],</span>
        <span class="n">mask_values</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">keep_mask_values</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bands_to_mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Masks pixels of bands in the collection using a boolean array.</span>

<span class="sd">        IMPORTANT:</span>
<span class="sd">            The mask band (or mask array) and the bands to mask **must**</span>
<span class="sd">            have the same shape!</span>

<span class="sd">        :param mask:</span>
<span class="sd">            either a band out of the collection (identified through its</span>
<span class="sd">            band name) or a ``numpy.ndarray`` of datatype boolean or</span>
<span class="sd">            another `Band` object</span>
<span class="sd">        :param mask_values:</span>
<span class="sd">            if `mask` is a band out of the collection, a list of values</span>
<span class="sd">            **must** be specified to create a boolean mask. Ignored if `mask`</span>
<span class="sd">            is already a boolean ``numpy.ndarray``</span>
<span class="sd">        :param keep_mask_values:</span>
<span class="sd">            if False (default), pixels in `mask` corresponding to `mask_values`</span>
<span class="sd">            are masked, otherwise all other pixel values are masked.</span>
<span class="sd">            Ignored if `mask` is already a boolean ``numpy.ndarray``.</span>
<span class="sd">        :param bands_to_mask:</span>
<span class="sd">            bands in the collection to mask based on `mask`. If not provided,</span>
<span class="sd">            all bands are masked</span>
<span class="sd">        :param inplace:</span>
<span class="sd">            if False returns a new `RasterCollection` (default) otherwise</span>
<span class="sd">            overwrites existing raster band entries</span>
<span class="sd">        :returns:</span>
<span class="sd">            new RasterCollection if `inplace==False`, None otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_mask</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="c1"># check mask and prepare it if required</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;When providing an array it must be boolean&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;When providing an array it must be 2-dimensional&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_mask</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">band_selection</span><span class="o">=</span><span class="p">[</span><span class="n">_mask</span><span class="p">])[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid mask band: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># translate mask band into boolean array</span>
            <span class="k">if</span> <span class="n">mask_values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;When using a band as mask, you have to provide a &quot;</span>
                    <span class="s2">&quot;list of mask values&quot;</span>
                <span class="p">)</span>
            <span class="c1"># convert the mask to a temporary binary mask</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">_mask</span><span class="p">)</span>
            <span class="c1"># set valid classes to 1, the other ones are zero</span>
            <span class="k">if</span> <span class="n">keep_mask_values</span><span class="p">:</span>
                <span class="c1"># drop all other values not in mask_values</span>
                <span class="n">tmp</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">_mask</span><span class="p">,</span> <span class="n">mask_values</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># drop all values in mask_values</span>
                <span class="n">tmp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">_mask</span><span class="p">,</span> <span class="n">mask_values</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">_mask</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_mask</span><span class="p">,</span> <span class="n">Band</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">_mask</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Mask must have boolean values not </span><span class="si">{</span><span class="n">_mask</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="n">_mask</span> <span class="o">=</span> <span class="n">_mask</span><span class="o">.</span><span class="n">values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Mask must be either band_name or np.ndarray not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">_mask</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># check bands to mask</span>
        <span class="k">if</span> <span class="n">bands_to_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bands_to_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_names</span>

        <span class="c1"># check shapes of bands and mask before applying the mask</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bandstack</span><span class="p">(</span><span class="n">band_selection</span><span class="o">=</span><span class="n">bands_to_mask</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Can only mask bands that have the same spatial extent, &quot;</span>
                <span class="s2">&quot;pixel size and CRS&quot;</span>
            <span class="p">)</span>

        <span class="c1"># initialize a new raster collection if inplace is False</span>
        <span class="n">collection</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_collection&quot;</span><span class="p">)</span>
            <span class="n">collection</span> <span class="o">=</span> <span class="n">RasterCollection</span><span class="p">(</span><span class="o">**</span><span class="n">attrs</span><span class="p">)</span>

        <span class="c1"># loop over band reproject the selected ones</span>
        <span class="k">for</span> <span class="n">band_name</span> <span class="ow">in</span> <span class="n">bands_to_mask</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">band_name</span><span class="p">]</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span><span class="n">mask</span><span class="o">=</span><span class="n">_mask</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">band</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_band</span><span class="p">(</span><span class="n">band_name</span><span class="p">))</span>
                <span class="n">collection</span><span class="o">.</span><span class="n">add_band</span><span class="p">(</span>
                    <span class="n">band_constructor</span><span class="o">=</span><span class="n">band</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">_mask</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">collection</span></div>

<div class="viewcode-block" id="RasterCollection.scale"><a class="viewcode-back" href="../../../packages/eodal.core.raster.html#eodal.core.raster.RasterCollection.scale">[docs]</a>    <span class="nd">@check_band_names</span>
    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">band_selection</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies gain and offset factors to bands in collection</span>

<span class="sd">        :param band_selection:</span>
<span class="sd">            selection of bands to process. If not provided uses all</span>
<span class="sd">            bands</span>
<span class="sd">        :param inplace:</span>
<span class="sd">            if False returns a new `RasterCollection` (default) otherwise</span>
<span class="sd">            overwrites existing raster band entries</span>
<span class="sd">        :param kwargs:</span>
<span class="sd">            optional kwargs to pass to `~eodal.core.band.Band.scale_data`</span>
<span class="sd">        :returns:</span>
<span class="sd">            `RasterCollection` if `inplace == False`, None otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">band_selection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">band_selection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_names</span>

        <span class="c1"># initialize a new raster collection if inplace is False</span>
        <span class="n">collection</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
            <span class="n">attrs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_collection&quot;</span><span class="p">)</span>
            <span class="n">collection</span> <span class="o">=</span> <span class="n">RasterCollection</span><span class="p">(</span><span class="o">**</span><span class="n">attrs</span><span class="p">)</span>

        <span class="c1"># loop over band reproject the selected ones</span>
        <span class="k">for</span> <span class="n">band_name</span> <span class="ow">in</span> <span class="n">band_selection</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">collection</span><span class="p">[</span><span class="n">band_name</span><span class="p">]</span><span class="o">.</span><span class="n">scale_data</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">band</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_band</span><span class="p">(</span><span class="n">band_name</span><span class="p">)</span>
                <span class="n">collection</span><span class="o">.</span><span class="n">add_band</span><span class="p">(</span>
                    <span class="n">band_constructor</span><span class="o">=</span><span class="n">band</span><span class="o">.</span><span class="n">scale_data</span><span class="p">,</span>
                    <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="c1"># within the band instance `inplace` must be True,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">collection</span></div>

    <span class="c1"># TODO: implement this!!!</span>
<div class="viewcode-block" id="RasterCollection.join"><a class="viewcode-back" href="../../../packages/eodal.core.raster.html#eodal.core.raster.RasterCollection.join">[docs]</a>    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Spatial join of one ``RasterCollection`` instance with another</span>
<span class="sd">        instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="RasterCollection.calc_si"><a class="viewcode-back" href="../../../packages/eodal.core.raster.html#eodal.core.raster.RasterCollection.calc_si">[docs]</a>    <span class="k">def</span> <span class="nf">calc_si</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">si_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">inplace</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">band_mapping</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates a spectral index based on color-names (set as band aliases)</span>

<span class="sd">        :param si_name:</span>
<span class="sd">            name of the spectral index to calculate (e.g., &#39;NDVI&#39;).</span>
<span class="sd">        :param inplace:</span>
<span class="sd">            if False, returns the calculated SI as numpy array (default), else</span>
<span class="sd">            adds the calculated SI as a new band to the RasterCollection</span>
<span class="sd">            object.</span>
<span class="sd">        :param band_mapping:</span>
<span class="sd">            ..versionadd 0.2.2::</span>
<span class="sd">            optional band mapping to use different color names instead</span>
<span class="sd">            of the default ones (e.g., nir_2 instead of nir_1 as default</span>
<span class="sd">            near-infrared band, which might be helpful for some sensor</span>
<span class="sd">            with more than one NIR band such as Sentinel-2 MSI).</span>
<span class="sd">            See ~`eodal.core.spectral_indices.SpectralIndices` how</span>
<span class="sd">            `band_mapping` must look like.</span>
<span class="sd">        :returns:</span>
<span class="sd">            ``np.ndarray`` or ``np.ma.MaskedArray`` if inplace is False, None</span>
<span class="sd">            otherwise (is added as band to the collection)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spectral_indices</span> <span class="o">=</span> <span class="n">SpectralIndices</span><span class="p">(</span><span class="n">band_mapping</span><span class="p">)</span>
        <span class="n">si_values</span> <span class="o">=</span> <span class="n">spectral_indices</span><span class="o">.</span><span class="n">calc_si</span><span class="p">(</span><span class="n">si_name</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="c1"># since SIs are floats by nature set the nodata value to np.nan</span>
        <span class="n">nodata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="c1"># look for spectral band with same shape to take geo-info from</span>
            <span class="n">geo_info</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">geo_info</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_names</span>
                <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">si_values</span><span class="o">.</span><span class="n">shape</span>
            <span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_band</span><span class="p">(</span>
                <span class="n">band_constructor</span><span class="o">=</span><span class="n">Band</span><span class="p">,</span>
                <span class="n">band_name</span><span class="o">=</span><span class="n">si_name</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span>
                <span class="n">geo_info</span><span class="o">=</span><span class="n">geo_info</span><span class="p">,</span>
                <span class="n">band_alias</span><span class="o">=</span><span class="n">si_name</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
                <span class="n">values</span><span class="o">=</span><span class="n">si_values</span><span class="p">,</span>
                <span class="n">nodata</span><span class="o">=</span><span class="n">nodata</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">si_values</span></div>

<div class="viewcode-block" id="RasterCollection.to_dataframe"><a class="viewcode-back" href="../../../packages/eodal.core.raster.html#eodal.core.raster.RasterCollection.to_dataframe">[docs]</a>    <span class="nd">@check_band_names</span>
    <span class="k">def</span> <span class="nf">to_dataframe</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">band_selection</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts the bands in collection to a ``GeoDataFrame``</span>

<span class="sd">        :param band_selection:</span>
<span class="sd">            selection of bands to process. If not provided uses all</span>
<span class="sd">            bands</span>
<span class="sd">        :returns:</span>
<span class="sd">            ``GeoDataFrame`` with point-like features denoting single</span>
<span class="sd">            pixel values across bands in the collection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">band_selection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">band_selection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_names</span>

        <span class="c1"># get the pixel values in the selection as DataFrames and merge</span>
        <span class="c1"># them on the geometry column</span>
        <span class="n">px_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">band_selection</span><span class="p">]</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]),</span> <span class="n">px_list</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">gdf</span></div>

<div class="viewcode-block" id="RasterCollection.to_rasterio"><a class="viewcode-back" href="../../../packages/eodal.core.raster.html#eodal.core.raster.RasterCollection.to_rasterio">[docs]</a>    <span class="k">def</span> <span class="nf">to_rasterio</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fpath_raster</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span>
        <span class="n">band_selection</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">use_band_aliases</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes bands in collection to a raster dataset on disk using</span>
<span class="sd">        ``rasterio`` drivers</span>

<span class="sd">        :param fpath_raster:</span>
<span class="sd">            file-path to the raster dataset (existing ones will be</span>
<span class="sd">            overwritten!)</span>
<span class="sd">        :param band_selection:</span>
<span class="sd">            selection of bands to process. If not provided uses all</span>
<span class="sd">            bands</span>
<span class="sd">        :param use_band_aliases:</span>
<span class="sd">            use band aliases instead of band names for setting raster</span>
<span class="sd">            band descriptions to the output dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check output file naming and driver</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">driver</span> <span class="o">=</span> <span class="n">driver_from_extension</span><span class="p">(</span><span class="n">fpath_raster</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Could not determine GDAL driver for &quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">fpath_raster</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># check band_selection, if not provided use all available bands</span>
        <span class="k">if</span> <span class="n">band_selection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">band_selection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_names</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">band_selection</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No band selected for writing to raster file&quot;</span><span class="p">)</span>

        <span class="c1"># make sure all bands share the same extent, pixel size and CRS</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bandstack</span><span class="p">(</span><span class="n">band_selection</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot write bands with different shapes, pixels sizes &quot;</span>
                <span class="s2">&quot;and CRS to raster data set&quot;</span>
            <span class="p">)</span>

        <span class="c1"># check for band aliases if they shall be used</span>
        <span class="k">if</span> <span class="n">use_band_aliases</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_band_aliases</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No band aliases available&quot;</span><span class="p">)</span>
            <span class="n">band_idxs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">band_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">band_selection</span><span class="p">]</span>
            <span class="n">band_selection</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">band_aliases</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">band_idxs</span><span class="p">]</span>

        <span class="c1"># check meta and update it with the selected driver for writing the result</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">band_selection</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">meta</span><span class="p">)</span>
        <span class="n">dtypes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">band_selection</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">dtypes</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="ne">UserWarning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Multiple data types found in arrays to write (</span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="n">dtypes</span><span class="p">)</span><span class="si">}</span><span class="s2">). &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Casting to highest data type&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">dtypes</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">dtype_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">dtypes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO: determine highest dtype</span>
            <span class="n">dtype_str</span> <span class="o">=</span> <span class="s2">&quot;float32&quot;</span>

        <span class="c1"># update driver, the number of bands and the metadata value</span>
        <span class="n">meta</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;driver&quot;</span><span class="p">:</span> <span class="n">driver</span><span class="p">,</span>
                <span class="s2">&quot;count&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">band_selection</span><span class="p">),</span>
                <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="n">dtype_str</span><span class="p">,</span>
                <span class="s2">&quot;nodata&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="p">[</span><span class="n">band_selection</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">nodata</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span>

        <span class="c1"># open the result dataset and try to write the bands</span>
        <span class="k">with</span> <span class="n">rio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fpath_raster</span><span class="p">,</span> <span class="s2">&quot;w+&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">meta</span><span class="p">)</span> <span class="k">as</span> <span class="n">dst</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">band_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">band_selection</span><span class="p">):</span>
                <span class="c1"># check with band name to set</span>
                <span class="n">dst</span><span class="o">.</span><span class="n">set_band_description</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">band_name</span><span class="p">)</span>
                <span class="c1"># write band data</span>
                <span class="n">band_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_band</span><span class="p">(</span><span class="n">band_name</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype_str</span><span class="p">)</span>
                <span class="c1"># set masked pixels to nodata</span>
                <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">band_name</span><span class="p">]</span><span class="o">.</span><span class="n">is_masked_array</span><span class="p">:</span>
                    <span class="n">vals</span> <span class="o">=</span> <span class="n">band_data</span><span class="o">.</span><span class="n">data</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">band_data</span><span class="o">.</span><span class="n">mask</span>
                    <span class="n">vals</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">band_name</span><span class="p">]</span><span class="o">.</span><span class="n">nodata</span>
                <span class="n">dst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">band_data</span><span class="p">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="RasterCollection.to_xarray"><a class="viewcode-back" href="../../../packages/eodal.core.raster.html#eodal.core.raster.RasterCollection.to_xarray">[docs]</a>    <span class="nd">@check_band_names</span>
    <span class="k">def</span> <span class="nf">to_xarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">band_selection</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts bands in collection a ``xarray.DataArray``</span>

<span class="sd">        :param band_selection:</span>
<span class="sd">            selection of bands to process. If not provided uses all</span>
<span class="sd">            bands</span>
<span class="sd">        :returns:</span>
<span class="sd">            `xarray.DataArray` created from RasterCollection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">band_selection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">band_selection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_names</span>

        <span class="c1"># bands must have same extent, pixel size and CRS</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bandstack</span><span class="p">(</span><span class="n">band_selection</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Selected bands must share same spatial extent, pixel size &quot;</span>
                <span class="s2">&quot;and coordinate system&quot;</span>
            <span class="p">)</span>
        <span class="c1"># loop over bands and convert them to xarray</span>
        <span class="n">band_xarr_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">band_attrs_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">band_name</span> <span class="ow">in</span> <span class="n">band_selection</span><span class="p">:</span>
            <span class="n">band_xarr</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">band_name</span><span class="p">]</span><span class="o">.</span><span class="n">to_xarray</span><span class="p">()</span>
            <span class="n">band_xarr_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">band_xarr</span><span class="p">)</span>
            <span class="c1"># extract attributes to avoid loosing them on concat</span>
            <span class="n">band_attrs_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">band_xarr</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>

        <span class="c1"># merge the single xarrays in the list into a single big one</span>
        <span class="n">xarr</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">band_xarr_list</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;band&quot;</span><span class="p">,</span> <span class="n">combine_attrs</span><span class="o">=</span><span class="s2">&quot;drop&quot;</span><span class="p">)</span>
        <span class="c1"># add the attributes from the concated objects</span>
        <span class="n">xarr_attrs</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">band_attrs_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">band_attr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">band_attrs_list</span><span class="p">):</span>
            <span class="c1"># skip first band as it already serves as reference</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">xarr_attrs</span><span class="p">:</span>
                <span class="c1"># tuples are extended with entries from the single bands</span>
                <span class="c1"># except the &#39;transform&#39; entry that remains the same</span>
                <span class="c1"># for all bands</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xarr_attrs</span><span class="p">[</span><span class="n">attr</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">attr</span> <span class="o">!=</span> <span class="s2">&quot;transform&quot;</span><span class="p">:</span>
                        <span class="n">attrs_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">xarr_attrs</span><span class="p">[</span><span class="n">attr</span><span class="p">])</span>
                        <span class="n">attrs_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">band_attr</span><span class="p">[</span><span class="n">attr</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">xarr_attrs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">attr</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">attrs_list</span><span class="p">)})</span>
        <span class="k">return</span> <span class="n">xarr</span><span class="o">.</span><span class="n">assign_attrs</span><span class="p">(</span><span class="n">xarr_attrs</span><span class="p">)</span></div></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">eodal</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Table of Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../packages/modules.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source/changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../py-modindex.html">Module Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../genindex.html">Index</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, Crop Science, Institute of Agricultural Sciences, D-USYS, ETH Zurich, Zurich, Switzerland;
Earth Observation of Agroecosystems Team, Division Agroecology and Environment, Agroscope, Zurich, Switzerland.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>